= Efficient Container Images
:encoding: utf-8
:numbered:

[[packaging.container-images.efficient-images]]
== 高效的容器镜像

将 Spring Boot 的 uber jar 打包为 Docker 镜像非常容易。然而，直接在 Docker 镜像中复制和运行 uber jar 存在一些缺点。在不解压的情况下运行 uber jar 时，总会有一定的开销，而在容器化环境中，这种开销可能会很明显。另一个问题是，将应用程序代码及其所有依赖项放在 Docker 镜像的一个层中并不是最优的。由于你可能比升级 Spring Boot 版本更频繁地重新编译代码，因此通常最好将这些东西分开一些。如果将 jar 文件放在应用程序类之前的层中，Docker 通常只需要更改最底层的层，并可以从其缓存中获取其他层。

[[packaging.container-images.efficient-images.layering]]
== 分层 Docker 镜像

为了更容易创建优化的 Docker 镜像，Spring Boot 支持向 jar 添加分层索引文件。它提供了层列表以及应包含在其中的 jar 部分。索引中的层列表基于应添加到 Docker/OCI 镜像的顺序进行排序。开箱即用，支持以下层：

* `dependencies`（用于常规发布的依赖项）
* `spring-boot-loader`（用于 `org/springframework/boot/loader` 下的所有内容）
* `snapshot-dependencies`（用于快照依赖项）
* `application`（用于应用程序类和资源）

以下是一个 `layers.idx` 文件的示例：

[source,yaml]
----
- "dependencies":
  - BOOT-INF/lib/library1.jar
  - BOOT-INF/lib/library2.jar
- "spring-boot-loader":
  - org/springframework/boot/loader/launch/JarLauncher.class
  - ... <其他类>
- "snapshot-dependencies":
  - BOOT-INF/lib/library3-SNAPSHOT.jar
- "application":
  - META-INF/MANIFEST.MF
  - BOOT-INF/classes/a/b/C.class
----

这种分层设计旨在根据代码在应用程序构建之间更改的可能性来分离代码。库代码在构建之间更改的可能性较小，因此将其放在自己的层中，以允许工具从缓存中重用这些层。应用程序代码在构建之间更改的可能性较大，因此将其隔离在一个单独的层中。

Spring Boot 还支持通过 `layers.idx` 对 war 文件进行分层。

对于 Maven，请参阅 xref:maven-plugin:packaging.adoc#packaging.layers[打包分层 jar 或 war 部分] 以获取有关向存档添加分层索引的更多详细信息。对于 Gradle，请参阅 Gradle 插件文档的 xref:gradle-plugin:packaging.adoc#packaging-executable.configuring.layered-archives[打包分层 jar 或 war 部分]。

'''

[[packaging.container-images.efficient-images]]
== Efficient Container Images
It is easily possible to package a Spring Boot uber jar as a Docker image.
However, there are various downsides to copying and running the uber jar as-is in the Docker image.
There’s always a certain amount of overhead when running an uber jar without unpacking it, and in a containerized environment this can be noticeable.
The other issue is that putting your application's code and all its dependencies in one layer in the Docker image is not optimal.
Since you probably recompile your code more often than you upgrade the version of Spring Boot you use, it’s often better to separate things a bit more.
If you put jar files in the layer before your application classes, Docker often only needs to change the very bottom layer and can pick others up from its cache.

[[packaging.container-images.efficient-images.layering]]
== Layering Docker Images
To make it easier to create optimized Docker images, Spring Boot supports adding a layer index file to the jar.
It provides a list of layers and the parts of the jar that should be contained within them.
The list of layers in the index is ordered based on the order in which the layers should be added to the Docker/OCI image.
Out-of-the-box, the following layers are supported:

* `dependencies` (for regular released dependencies)
* `spring-boot-loader` (for everything under `org/springframework/boot/loader`)
* `snapshot-dependencies` (for snapshot dependencies)
* `application` (for application classes and resources)

The following shows an example of a `layers.idx` file:

[source,yaml]
----
- "dependencies":
  - BOOT-INF/lib/library1.jar
  - BOOT-INF/lib/library2.jar
- "spring-boot-loader":
  - org/springframework/boot/loader/launch/JarLauncher.class
  - ... <other classes>
- "snapshot-dependencies":
  - BOOT-INF/lib/library3-SNAPSHOT.jar
- "application":
  - META-INF/MANIFEST.MF
  - BOOT-INF/classes/a/b/C.class
----

This layering is designed to separate code based on how likely it is to change between application builds.
Library code is less likely to change between builds, so it is placed in its own layers to allow tooling to re-use the layers from cache.
Application code is more likely to change between builds so it is isolated in a separate layer.

Spring Boot also supports layering for war files with the help of a `layers.idx`.

For Maven, see the xref:maven-plugin:packaging.adoc#packaging.layers[packaging layered jar or war section] for more details on adding a layer index to the archive.
For Gradle, see the xref:gradle-plugin:packaging.adoc#packaging-executable.configuring.layered-archives[packaging layered jar or war section] of the Gradle plugin documentation.
