= Testcontainers
:encoding: utf-8
:numbered:

[[testing.testcontainers]]
== Testcontainers
https://www.testcontainers.org/[Testcontainers] 库提供了一种管理运行在 Docker 容器中的服务的方式。它与 JUnit 集成，允许你编写一个测试类，在运行任何测试之前启动容器。Testcontainers 特别适用于编写与真实后端服务（如 MySQL、MongoDB、Cassandra 等）通信的集成测试。

Testcontainers 可以在 Spring Boot 测试中使用，如下所示：

include-code::vanilla/MyIntegrationTests[]

这将在运行任何测试之前启动一个运行 Neo4j 的 Docker 容器（如果 Docker 在本地运行）。在大多数情况下，你需要配置应用程序以连接到在容器中运行的服务。

[[testing.testcontainers.service-connections]]
== 服务连接

服务连接是指与任何远程服务的连接。Spring Boot 的自动配置可以消费服务连接的详细信息，并使用它们建立与远程服务的连接。这样做时，连接详细信息优先于任何与连接相关的配置属性。

当使用 Testcontainers 时，可以通过在测试类中标注容器字段来自动创建与容器中运行的服务的连接详细信息。

include-code::MyIntegrationTests[]

由于 `@ServiceConnection`，上述配置允许应用程序中的 Neo4j 相关 Bean 与 Testcontainers 管理的 Docker 容器中运行的 Neo4j 通信。这是通过自动定义一个 `Neo4jConnectionDetails` Bean 来实现的，然后由 Neo4j 自动配置使用该 Bean，覆盖任何与连接相关的配置属性。

NOTE: 你需要将 `spring-boot-testcontainers` 模块添加为测试依赖项，以便与 Testcontainers 一起使用服务连接。

服务连接注解由注册在 `spring.factories` 中的 `ContainerConnectionDetailsFactory` 类处理。`ContainerConnectionDetailsFactory` 可以根据特定的 `Container` 子类或 Docker 镜像名称创建 `ConnectionDetails` Bean。

`spring-boot-testcontainers` jar 中提供了以下服务连接工厂：

|===
| 连接详细信息 | 匹配条件

| `ActiveMQConnectionDetails`
| 名为 "symptoma/activemq" 的容器或 `ActiveMQContainer`

| `ArtemisConnectionDetails`
| `ArtemisContainer` 类型的容器

| `CassandraConnectionDetails`
| `CassandraContainer` 类型的容器

| `CouchbaseConnectionDetails`
| `CouchbaseContainer` 类型的容器

| `ElasticsearchConnectionDetails`
| `ElasticsearchContainer` 类型的容器

| `FlywayConnectionDetails`
| `JdbcDatabaseContainer` 类型的容器

| `JdbcConnectionDetails`
| `JdbcDatabaseContainer` 类型的容器

| `KafkaConnectionDetails`
| `KafkaContainer`、`ConfluentKafkaContainer` 或 `RedpandaContainer` 类型的容器

| `LiquibaseConnectionDetails`
| `JdbcDatabaseContainer` 类型的容器

| `MongoConnectionDetails`
| `MongoDBContainer` 类型的容器

| `Neo4jConnectionDetails`
| `Neo4jContainer` 类型的容器

| `OtlpLoggingConnectionDetails`
| 名为 "otel/opentelemetry-collector-contrib" 的容器或 `LgtmStackContainer` 类型的容器

| `OtlpMetricsConnectionDetails`
| 名为 "otel/opentelemetry-collector-contrib" 的容器或 `LgtmStackContainer` 类型的容器

| `OtlpTracingConnectionDetails`
| 名为 "otel/opentelemetry-collector-contrib" 的容器或 `LgtmStackContainer` 类型的容器

| `PulsarConnectionDetails`
| `PulsarContainer` 类型的容器

| `R2dbcConnectionDetails`
| `ClickHouseContainer`、`MariaDBContainer`、`MSSQLServerContainer`、`MySQLContainer`、`OracleContainer`（免费版）、`OracleContainer`（XE 版）或 `PostgreSQLContainer` 类型的容器

| `RabbitConnectionDetails`
| `RabbitMQContainer` 类型的容器

| `RedisConnectionDetails`
| `RedisContainer` 或 `RedisStackContainer` 类型的容器，或名为 "redis"、"redis/redis-stack" 或 "redis/redis-stack-server" 的容器

| `ZipkinConnectionDetails`
| 名为 "openzipkin/zipkin" 的容器
|===

[TIP]
====
默认情况下，将为给定的 `Container` 创建所有适用的连接详细信息 Bean。例如，`PostgreSQLContainer` 将创建 `JdbcConnectionDetails` 和 `R2dbcConnectionDetails`。

如果你只想创建适用类型的子集，可以使用 `@ServiceConnection` 的 `type` 属性。
====

默认情况下，使用 `Container.getDockerImageName().getRepository()` 获取用于查找连接详细信息的名称。Docker 镜像名称的存储库部分忽略任何注册表和版本。只要 Spring Boot 能够获取 `Container` 的实例，这就可以正常工作，就像在上面的示例中使用 `static` 字段时一样。

如果你使用 `@Bean` 方法，Spring Boot 不会调用 Bean 方法来获取 Docker 镜像名称，因为这会导致急切初始化问题。相反，使用 Bean 方法的返回类型来确定应使用哪种连接详细信息。只要你使用类型化的容器（如 `Neo4jContainer` 或 `RabbitMQContainer`），这就可以正常工作。如果你使用 `GenericContainer`，例如以下示例中的 Redis，这将停止工作：

include-code::MyRedisConfiguration[]

Spring Boot 无法从 `GenericContainer` 中判断使用了哪个容器镜像，因此必须使用 `@ServiceConnection` 的 `name` 属性来提供提示。

你还可以使用 `@ServiceConnection` 的 `name` 属性来覆盖将使用的连接详细信息，例如在使用自定义镜像时。如果你使用的是 Docker 镜像 `registry.mycompany.com/mirror/myredis`，你将使用 `@ServiceConnection(name="redis")` 来确保创建 `RedisConnectionDetails`。

[[testing.testcontainers.dynamic-properties]]
== 动态属性

与服务连接相比，`@DynamicPropertySource` 是一种稍微冗长但更灵活的替代方案。静态的 `@DynamicPropertySource` 方法允许向 Spring 环境添加动态属性值。

include-code::MyIntegrationTests[]

上述配置允许应用程序中的 Neo4j 相关 Bean 与 Testcontainers 管理的 Docker 容器中运行的 Neo4j 通信。

'''
[[testing.testcontainers]]
== Testcontainers
The https://www.testcontainers.org/[Testcontainers] library provides a way to manage services running inside Docker containers.
It integrates with JUnit, allowing you to write a test class that can start up a container before any of the tests run.
Testcontainers is especially useful for writing integration tests that talk to a real backend service such as MySQL, MongoDB, Cassandra and others.

Testcontainers can be used in a Spring Boot test as follows:

include-code::vanilla/MyIntegrationTests[]

This will start up a docker container running Neo4j (if Docker is running locally) before any of the tests are run.
In most cases, you will need to configure the application to connect to the service running in the container.

[[testing.testcontainers.service-connections]]
== Service Connections
A service connection is a connection to any remote service.
Spring Boot's auto-configuration can consume the details of a service connection and use them to establish a connection to a remote service.
When doing so, the connection details take precedence over any connection-related configuration properties.

When using Testcontainers, connection details can be automatically created for a service running in a container by annotating the container field in the test class.

include-code::MyIntegrationTests[]

Thanks to javadoc:org.springframework.boot.testcontainers.service.connection.ServiceConnection[format=annotation], the above configuration allows Neo4j-related beans in the application to communicate with Neo4j running inside the Testcontainers-managed Docker container.
This is done by automatically defining a javadoc:org.springframework.boot.autoconfigure.neo4j.Neo4jConnectionDetails[] bean which is then used by the Neo4j auto-configuration, overriding any connection-related configuration properties.

NOTE: You'll need to add the `spring-boot-testcontainers` module as a test dependency in order to use service connections with Testcontainers.

Service connection annotations are processed by javadoc:org.springframework.boot.testcontainers.service.connection.ContainerConnectionDetailsFactory[] classes registered with `spring.factories`.
A javadoc:org.springframework.boot.testcontainers.service.connection.ContainerConnectionDetailsFactory[] can create a javadoc:org.springframework.boot.autoconfigure.service.connection.ConnectionDetails[] bean based on a specific javadoc:org.testcontainers.containers.Container[] subclass, or the Docker image name.

The following service connection factories are provided in the `spring-boot-testcontainers` jar:

|===
| Connection Details | Matched on

| javadoc:org.springframework.boot.autoconfigure.jms.activemq.ActiveMQConnectionDetails[]
| Containers named "symptoma/activemq" or javadoc:org.testcontainers.activemq.ActiveMQContainer[]

| javadoc:org.springframework.boot.autoconfigure.jms.artemis.ArtemisConnectionDetails[]
| Containers of type javadoc:org.testcontainers.activemq.ArtemisContainer[]

| javadoc:org.springframework.boot.autoconfigure.cassandra.CassandraConnectionDetails[]
| Containers of type javadoc:org.testcontainers.cassandra.CassandraContainer[]

| javadoc:org.springframework.boot.autoconfigure.couchbase.CouchbaseConnectionDetails[]
| Containers of type javadoc:org.testcontainers.couchbase.CouchbaseContainer[]

| javadoc:org.springframework.boot.autoconfigure.elasticsearch.ElasticsearchConnectionDetails[]
| Containers of type javadoc:org.testcontainers.elasticsearch.ElasticsearchContainer[]

| javadoc:org.springframework.boot.autoconfigure.flyway.FlywayConnectionDetails[]
| Containers of type javadoc:{url-testcontainers-jdbc-javadoc}/org.testcontainers.containers.JdbcDatabaseContainer[]

| javadoc:org.springframework.boot.autoconfigure.jdbc.JdbcConnectionDetails[]
| Containers of type javadoc:{url-testcontainers-jdbc-javadoc}/org.testcontainers.containers.JdbcDatabaseContainer[]

| javadoc:org.springframework.boot.autoconfigure.kafka.KafkaConnectionDetails[]
| Containers of type javadoc:org.testcontainers.kafka.KafkaContainer[], javadoc:org.testcontainers.kafka.ConfluentKafkaContainer[] or javadoc:org.testcontainers.redpanda.RedpandaContainer[]

| javadoc:org.springframework.boot.autoconfigure.liquibase.LiquibaseConnectionDetails[]
| Containers of type javadoc:{url-testcontainers-jdbc-javadoc}/org.testcontainers.containers.JdbcDatabaseContainer[]

| javadoc:org.springframework.boot.autoconfigure.mongo.MongoConnectionDetails[]
| Containers of type javadoc:{url-testcontainers-mongodb-javadoc}/org.testcontainers.containers.MongoDBContainer[]

| javadoc:org.springframework.boot.autoconfigure.neo4j.Neo4jConnectionDetails[]
| Containers of type javadoc:{url-testcontainers-neo4j-javadoc}/org.testcontainers.containers.Neo4jContainer[]

| javadoc:org.springframework.boot.actuate.autoconfigure.logging.otlp.OtlpLoggingConnectionDetails[]
| Containers named "otel/opentelemetry-collector-contrib" or of type `LgtmStackContainer`

| javadoc:org.springframework.boot.actuate.autoconfigure.metrics.export.otlp.OtlpMetricsConnectionDetails[]
| Containers named "otel/opentelemetry-collector-contrib" or of type `LgtmStackContainer`

| javadoc:org.springframework.boot.actuate.autoconfigure.tracing.otlp.OtlpTracingConnectionDetails[]
| Containers named "otel/opentelemetry-collector-contrib" or of type `LgtmStackContainer`

| javadoc:org.springframework.boot.autoconfigure.pulsar.PulsarConnectionDetails[]
| Containers of type javadoc:{url-testcontainers-pulsar-javadoc}/org.testcontainers.containers.PulsarContainer[]

| javadoc:org.springframework.boot.autoconfigure.r2dbc.R2dbcConnectionDetails[]
| Containers of type `ClickHouseContainer`, javadoc:{url-testcontainers-mariadb-javadoc}/org.testcontainers.containers.MariaDBContainer[], javadoc:{url-testcontainers-mssqlserver-javadoc}/org.testcontainers.containers.MSSQLServerContainer[], javadoc:{url-testcontainers-mysql-javadoc}/org.testcontainers.containers.MySQLContainer[], javadoc:{url-testcontainers-oracle-free-javadoc}/org.testcontainers.OracleContainer[OracleContainer (free)], javadoc:{url-testcontainers-oracle-xe-javadoc}/org.testcontainers.oracle.OracleContainer[OracleContainer (XE)] or javadoc:{url-testcontainers-postgresql-javadoc}/org.testcontainers.containers.PostgreSQLContainer[]

| javadoc:org.springframework.boot.autoconfigure.amqp.RabbitConnectionDetails[]
| Containers of type javadoc:{url-testcontainers-rabbitmq-javadoc}/org.testcontainers.containers.RabbitMQContainer[]

| javadoc:org.springframework.boot.autoconfigure.data.redis.RedisConnectionDetails[]
| Containers of type javadoc:com.redis.testcontainers.RedisContainer[] or javadoc:com.redis.testcontainers.RedisStackContainer[], or containers named "redis", "redis/redis-stack" or "redis/redis-stack-server"

| javadoc:org.springframework.boot.actuate.autoconfigure.tracing.zipkin.ZipkinConnectionDetails[]
| Containers named "openzipkin/zipkin"
|===

[TIP]
====
By default all applicable connection details beans will be created for a given javadoc:org.testcontainers.containers.Container[].
For example, a javadoc:{url-testcontainers-postgresql-javadoc}/org.testcontainers.containers.PostgreSQLContainer[] will create both javadoc:org.springframework.boot.autoconfigure.jdbc.JdbcConnectionDetails[] and javadoc:org.springframework.boot.autoconfigure.r2dbc.R2dbcConnectionDetails[].

If you want to create only a subset of the applicable types, you can use the `type` attribute of javadoc:org.springframework.boot.testcontainers.service.connection.ServiceConnection[format=annotation].
====

By default `Container.getDockerImageName().getRepository()` is used to obtain the name used to find connection details.
The repository portion of the Docker image name ignores any registry and the version.
This works as long as Spring Boot is able to get the instance of the javadoc:org.testcontainers.containers.Container[], which is the case when using a `static` field like in the example above.

If you're using a javadoc:org.springframework.context.annotation.Bean[format=annotation] method, Spring Boot won't call the bean method to get the Docker image name, because this would cause eager initialization issues.
Instead, the return type of the bean method is used to find out which connection detail should be used.
This works as long as you're using typed containers such as javadoc:{url-testcontainers-neo4j-javadoc}/org.testcontainers.containers.Neo4jContainer[] or javadoc:{url-testcontainers-rabbitmq-javadoc}/org.testcontainers.containers.RabbitMQContainer[].
This stops working if you're using javadoc:org.testcontainers.containers.GenericContainer[], for example with Redis as shown in the following example:

include-code::MyRedisConfiguration[]

Spring Boot can't tell from javadoc:org.testcontainers.containers.GenericContainer[] which container image is used, so the `name` attribute from javadoc:org.springframework.boot.testcontainers.service.connection.ServiceConnection[format=annotation] must be used to provide that hint.

You can also use the `name` attribute of javadoc:org.springframework.boot.testcontainers.service.connection.ServiceConnection[format=annotation] to override which connection detail will be used, for example when using custom images.
If you are using the Docker image `registry.mycompany.com/mirror/myredis`, you'd use `@ServiceConnection(name="redis")` to ensure javadoc:org.springframework.boot.autoconfigure.data.redis.RedisConnectionDetails[] are created.

[[testing.testcontainers.dynamic-properties]]
== Dynamic Properties
A slightly more verbose but also more flexible alternative to service connections is javadoc:org.springframework.test.context.DynamicPropertySource[format=annotation].
A static javadoc:org.springframework.test.context.DynamicPropertySource[format=annotation] method allows adding dynamic property values to the Spring Environment.

include-code::MyIntegrationTests[]

The above configuration allows Neo4j-related beans in the application to communicate with Neo4j running inside the Testcontainers-managed Docker container.
