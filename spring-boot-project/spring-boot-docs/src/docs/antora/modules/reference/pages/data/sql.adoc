= SQL 数据库
:encoding: utf-8
:numbered:

[[data.sql]]
== SQL 数据库
{url-spring-framework-site}[Spring Framework] 提供了对 SQL 数据库的广泛支持，从使用 javadoc:org.springframework.jdbc.core.simple.JdbcClient[] 或 javadoc:org.springframework.jdbc.core.JdbcTemplate[] 的直接 JDBC 访问，到完整的“对象关系映射”技术（如 Hibernate）。
{url-spring-data-site}[Spring Data] 提供了额外的功能：直接从接口创建 javadoc:org.springframework.data.repository.Repository[] 实现，并使用约定从方法名称生成查询。

[[data.sql.datasource]]
== 配置数据源
Java 的 javadoc:javax.sql.DataSource[] 接口提供了与数据库连接交互的标准方法。
传统上，javadoc:javax.sql.DataSource[] 使用 `URL` 和一些凭据来建立数据库连接。

TIP: 有关更高级的示例，请参阅“操作指南”中的 xref:how-to:data-access.adoc#howto.data-access.configure-custom-datasource[] 部分，通常是为了完全控制数据源的配置。

[[data.sql.datasource.embedded]]
=== 嵌入式数据库支持
使用内存嵌入式数据库开发应用程序通常非常方便。
显然，内存数据库不提供持久存储。
你需要在应用程序启动时填充数据库，并在应用程序结束时准备好丢弃数据。

TIP: “操作指南”部分包含一个关于 xref:how-to:data-initialization.adoc[如何初始化数据库] 的部分。

Spring Boot 可以自动配置嵌入式 https://www.h2database.com[H2]、https://hsqldb.org/[HSQL] 和 https://db.apache.org/derby/[Derby] 数据库。
你不需要提供任何连接 URL。
你只需包含要使用的嵌入式数据库的构建依赖项。
如果类路径上有多个嵌入式数据库，请设置 configprop:spring.datasource.embedded-database-connection[] 配置属性以控制使用哪个数据库。
将该属性设置为 `none` 将禁用嵌入式数据库的自动配置。

[NOTE]
====
如果你在测试中使用此功能，你可能会注意到，无论使用多少个应用程序上下文，整个测试套件都会重用同一个数据库。
如果你希望确保每个上下文都有一个单独的嵌入式数据库，应将 `spring.datasource.generate-unique-name` 设置为 `true`。
====

例如，典型的 POM 依赖项如下：

[source,xml]
----
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>
<dependency>
	<groupId>org.hsqldb</groupId>
	<artifactId>hsqldb</artifactId>
	<scope>runtime</scope>
</dependency>
----

NOTE: 你需要依赖 `spring-jdbc` 才能自动配置嵌入式数据库。
在此示例中，它通过 `spring-boot-starter-data-jpa` 传递引入。

TIP: 如果出于某种原因，你为嵌入式数据库配置了连接 URL，请确保禁用数据库的自动关闭。
如果使用 H2，应使用 `DB_CLOSE_ON_EXIT=FALSE` 来实现。
如果使用 HSQLDB，请确保不使用 `shutdown=true`。
禁用数据库的自动关闭可以让 Spring Boot 控制数据库的关闭时间，从而确保在不再需要访问数据库时关闭它。

[[data.sql.datasource.production]]
=== 连接到生产数据库
生产数据库连接也可以通过使用池化的 javadoc:javax.sql.DataSource[] 自动配置。

[[data.sql.datasource.configuration]]
=== 数据源配置
数据源配置由 `+spring.datasource.*+` 中的外部配置属性控制。
例如，你可以在 `application.properties` 中声明以下部分：

[configprops,yaml]
----
spring:
  datasource:
    url: "jdbc:mysql://localhost/test"
    username: "dbuser"
    password: "dbpass"
----

NOTE: 你至少应通过设置 configprop:spring.datasource.url[] 属性来指定 URL。
否则，Spring Boot 会尝试自动配置嵌入式数据库。

TIP: Spring Boot 可以从 URL 推断出大多数数据库的 JDBC 驱动程序类。
如果需要指定特定类，可以使用 configprop:spring.datasource.driver-class-name[] 属性。

NOTE: 要创建池化的 javadoc:javax.sql.DataSource[]，我们需要能够验证有效的 javadoc:java.sql.Driver[] 类是否可用，因此我们在执行任何操作之前会进行检查。
换句话说，如果你设置 `spring.datasource.driver-class-name=com.mysql.jdbc.Driver`，则该类必须可加载。

有关更多支持的选项，请参阅 javadoc:org.springframework.boot.autoconfigure.jdbc.DataSourceProperties[] API 文档。
这些是标准选项，无论 xref:data/sql.adoc#data.sql.datasource.connection-pool[实际实现] 如何，它们都适用。
还可以使用各自的前缀（`+spring.datasource.hikari.*+`、`+spring.datasource.tomcat.*+`、`+spring.datasource.dbcp2.*+` 和 `+spring.datasource.oracleucp.*+`）微调特定于实现的设置。
有关更多详细信息，请参阅你使用的连接池实现的文档。

例如，如果你使用 {url-tomcat-docs}/jdbc-pool.html#Common_Attributes[Tomcat 连接池]，则可以自定义许多其他设置，如下例所示：

[configprops,yaml]
----
spring:
  datasource:
    tomcat:
      max-wait: 10000
      max-active: 50
      test-on-borrow: true
----

这将设置连接池在没有可用连接时等待 10000 毫秒后再抛出异常，将最大连接数限制为 50，并在从池中借用连接之前验证连接。

[[data.sql.datasource.connection-pool]]
=== 支持的连接池
Spring Boot 使用以下算法选择特定实现：

1. 我们更喜欢 https://github.com/brettwooldridge/HikariCP[HikariCP]，因为它的性能和并发性。
如果 HikariCP 可用，我们总是选择它。
2. 否则，如果 Tomcat 池化的 javadoc:javax.sql.DataSource[] 可用，我们使用它。
3. 否则，如果 https://commons.apache.org/proper/commons-dbcp/[Commons DBCP2] 可用，我们使用它。
4. 如果 HikariCP、Tomcat 和 DBCP2 都不可用，并且如果 Oracle UCP 可用，我们使用它。

NOTE: 如果你使用 `spring-boot-starter-jdbc` 或 `spring-boot-starter-data-jpa` 启动器，你会自动获得对 HikariCP 的依赖。

你可以通过设置 configprop:spring.datasource.type[] 属性完全绕过该算法并指定要使用的连接池。
这在 Tomcat 容器中运行应用程序时尤其重要，因为默认情况下会提供 `tomcat-jdbc`。

始终可以使用 javadoc:org.springframework.boot.jdbc.DataSourceBuilder[] 手动配置其他连接池。
如果你定义了自己的 javadoc:javax.sql.DataSource[] bean，则不会发生自动配置。
javadoc:org.springframework.boot.jdbc.DataSourceBuilder[] 支持以下连接池：

* HikariCP
* Tomcat 池化的 javadoc:javax.sql.DataSource[]
* Commons DBCP2
* Oracle UCP 和 `OracleDataSource`
* Spring Framework 的 javadoc:org.springframework.jdbc.datasource.SimpleDriverDataSource[]
* H2 的 javadoc:org.h2.jdbcx.JdbcDataSource[]
* PostgreSQL 的 javadoc:org.postgresql.ds.PGSimpleDataSource[]
* C3P0

[[data.sql.datasource.jndi]]
=== 连接到 JNDI 数据源
如果将 Spring Boot 应用程序部署到应用服务器，你可能希望使用应用服务器的内置功能配置和管理数据源，并通过 JNDI 访问它。

configprop:spring.datasource.jndi-name[] 属性可以用作 configprop:spring.datasource.url[]、configprop:spring.datasource.username[] 和 configprop:spring.datasource.password[] 属性的替代方案，以从特定 JNDI 位置访问 javadoc:javax.sql.DataSource[]。
例如，`application.properties` 中的以下部分显示了如何访问 JBoss AS 定义的 javadoc:javax.sql.DataSource[]：

[configprops,yaml]
----
spring:
  datasource:
    jndi-name: "java:jboss/datasources/customers"
----

[[data.sql.jdbc-template]]
== 使用 JdbcTemplate
Spring 的 javadoc:org.springframework.jdbc.core.JdbcTemplate[] 和 javadoc:org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate[] 类是自动配置的，你可以直接将它们自动注入到你自己的 bean 中，如下例所示：

include-code::MyBean[]

你可以使用 `spring.jdbc.template.*` 属性自定义模板的某些属性，如下例所示：

[configprops,yaml]
----
spring:
  jdbc:
    template:
      max-rows: 500
----

NOTE: javadoc:org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate[] 在幕后重用相同的 javadoc:org.springframework.jdbc.core.JdbcTemplate[] 实例。
如果定义了多个 javadoc:org.springframework.jdbc.core.JdbcTemplate[] 且没有主要候选者，则不会自动配置 javadoc:org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate[]。

[[data.sql.jdbc-client]]
== 使用 JdbcClient
Spring 的 javadoc:org.springframework.jdbc.core.simple.JdbcClient[] 基于 javadoc:org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate[] 的存在自动配置。
你也可以将其直接注入到你自己的 bean 中，如下例所示：

include-code::MyBean[]

如果你依赖自动配置来创建底层的 javadoc:org.springframework.jdbc.core.JdbcTemplate[]，则使用 `spring.jdbc.template.*` 属性进行的任何自定义也会在客户端中生效。

[[data.sql.jpa-and-spring-data]]
== JPA 和 Spring Data JPA
Java Persistence API 是一种标准技术，允许你将对象“映射”到关系数据库。
`spring-boot-starter-data-jpa` POM 提供了一种快速入门的方式。
它提供了以下关键依赖项：

* Hibernate：最流行的 JPA 实现之一。
* Spring Data JPA：帮助你实现基于 JPA 的存储库。
* Spring ORM：Spring Framework 的核心 ORM 支持。

TIP: 我们不会在这里深入讨论 JPA 或 {url-spring-data-site}[Spring Data] 的细节。
你可以按照 https://spring.io/guides/gs/accessing-data-jpa/[使用 JPA 访问数据] 指南，并阅读 {url-spring-data-jpa-site}[Spring Data JPA] 和 https://hibernate.org/orm/documentation/[Hibernate] 参考文档。

[[data.sql.jpa-and-spring-data.entity-classes]]
=== 实体类
传统上，JPA“实体”类在 `persistence.xml` 文件中指定。
使用 Spring Boot 时，不需要此文件，而是使用“实体扫描”。
默认情况下，xref:using/auto-configuration.adoc#using.auto-configuration.packages[自动配置包] 会被扫描。

任何使用 javadoc:jakarta.persistence.Entity[format=annotation]、javadoc:jakarta.persistence.Embeddable[format=annotation] 或 javadoc:jakarta.persistence.MappedSuperclass[format=annotation] 注解的类都会被考虑。
典型的实体类如下例所示：

include-code::City[]

TIP: 你可以使用 javadoc:org.springframework.boot.autoconfigure.domain.EntityScan[format=annotation] 注解自定义实体扫描位置。
请参阅“操作指南”中的 xref:how-to:data-access.adoc#howto.data-access.separate-entity-definitions-from-spring-configuration[] 部分。

[[data.sql.jpa-and-spring-data.repositories]]
=== Spring Data JPA 存储库
{url-spring-data-jpa-site}[Spring Data JPA] 存储库是你可以定义以访问数据的接口。
JPA 查询会自动从你的方法名称创建。
例如，`CityRepository` 接口可能会声明一个 `findAllByState(String state)` 方法，以查找给定州的所有城市。

对于更复杂的查询，你可以使用 Spring Data 的 javadoc:org.springframework.data.jpa.repository.Query[] 注解来注解你的方法。

Spring Data 存储库通常扩展自 javadoc:org.springframework.data.repository.Repository[] 或 javadoc:org.springframework.data.repository.CrudRepository[] 接口。
如果使用自动配置，则会在 xref:using/auto-configuration.adoc#using.auto-configuration.packages[自动配置包] 中搜索存储库。

TIP: 你可以使用 javadoc:org.springframework.data.jpa.repository.config.EnableJpaRepositories[format=annotation] 自定义查找存储库的位置。

以下示例显示了一个典型的 Spring Data 存储库接口定义：

include-code::CityRepository[]

Spring Data JPA 存储库支持三种不同的引导模式：默认、延迟和惰性。
要启用延迟或惰性引导，请将 configprop:spring.data.jpa.repositories.bootstrap-mode[] 属性分别设置为 `deferred` 或 `lazy`。
当使用延迟或惰性引导时，自动配置的 javadoc:org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder[] 将使用上下文的 javadoc:org.springframework.core.task.AsyncTaskExecutor[]（如果有）作为引导执行器。
如果有多个，则使用名为 `applicationTaskExecutor` 的执行器。

[NOTE]
====
使用延迟或惰性引导时，请确保在应用程序上下文引导阶段之后延迟访问 JPA 基础设施。
你可以使用 javadoc:org.springframework.beans.factory.SmartInitializingSingleton[] 来调用需要 JPA 基础设施的任何初始化。
对于作为 Spring bean 创建的 JPA 组件（例如转换器），请使用 javadoc:org.springframework.beans.factory.ObjectProvider[] 来延迟依赖项的解析（如果有）。
====

TIP: 我们只是浅尝辄止地介绍了 Spring Data JPA。
有关完整详细信息，请参阅 {url-spring-data-jpa-docs}[Spring Data JPA 参考文档]。

[[data.sql.jpa-and-spring-data.envers-repositories]]
=== Spring Data Envers 存储库
如果 {url-spring-data-envers-site}[Spring Data Envers] 可用，JPA 存储库会自动配置以支持典型的 Envers 查询。

要使用 Spring Data Envers，请确保你的存储库扩展自 javadoc:org.springframework.data.repository.history.RevisionRepository[]，如下例所示：

include-code::CountryRepository[]

NOTE: 有关更多详细信息，请参阅 {url-spring-data-jpa-docs}/envers.html[Spring Data Envers 参考文档]。

[[data.sql.jpa-and-spring-data.creating-and-dropping]]
=== 创建和删除 JPA 数据库
默认情况下，*仅*当你使用嵌入式数据库（H2、HSQL 或 Derby）时，JPA 数据库才会自动创建。
你可以使用 `+spring.jpa.*+` 属性显式配置 JPA 设置。
例如，要创建和删除表，你可以在 `application.properties` 中添加以下行：

[configprops,yaml]
----
spring:
  jpa:
    hibernate.ddl-auto: "create-drop"
----

NOTE: Hibernate 自己的内部属性名称（如果你更容易记住）是 `hibernate.hbm2ddl.auto`。
你可以使用 `+spring.jpa.properties.*+`（在将它们添加到实体管理器之前会去除前缀）来设置它以及其他 Hibernate 原生属性。
以下行显示了为 Hibernate 设置 JPA 属性的示例：

[configprops,yaml]
----
spring:
  jpa:
    properties:
      hibernate:
        "globally_quoted_identifiers": "true"
----

上例中的行将 `hibernate.globally_quoted_identifiers` 属性的值 `true` 传递给 Hibernate 实体管理器。

默认情况下，DDL 执行（或验证）会延迟到 javadoc:org.springframework.context.ApplicationContext[] 启动后。

[[data.sql.jpa-and-spring-data.open-entity-manager-in-view]]
=== 在视图中打开 EntityManager
如果你运行的是 Web 应用程序，Spring Boot 默认会注册 javadoc:org.springframework.orm.jpa.support.OpenEntityManagerInViewInterceptor[] 以应用“在视图中打开 EntityManager”模式，以允许在 Web 视图中进行延迟加载。
如果你不希望此行为，应在 `application.properties` 中将 `spring.jpa.open-in-view` 设置为 `false`。

[[data.sql.jdbc]]
== Spring Data JDBC
Spring Data 包括对 JDBC 的存储库支持，并会自动为 javadoc:org.springframework.data.repository.CrudRepository[] 上的方法生成 SQL。
对于更高级的查询，提供了 javadoc:org.springframework.data.jdbc.repository.query.Query[format=annotation] 注解。

当类路径上有必要的依赖项时，Spring Boot 会自动配置 Spring Data 的 JDBC 存储库。
它们可以通过对 `spring-boot-starter-data-jdbc` 的单一依赖项添加到你的项目中。
如果需要，你可以通过添加 javadoc:org.springframework.data.jdbc.repository.config.EnableJdbcRepositories[format=annotation] 注解或 javadoc:org.springframework.data.jdbc.repository.config.AbstractJdbcConfiguration[] 子类来控制 Spring Data JDBC 的配置。

TIP: 有关 Spring Data JDBC 的完整详细信息，请参阅 {url-spring-data-jdbc-docs}[参考文档]。

[[data.sql.h2-web-console]]
== 使用 H2 的 Web 控制台
https://www.h2database.com[H2 数据库] 提供了一个 https://www.h2database.com/html/quickstart.html#h2_console[基于浏览器的控制台]，Spring Boot 可以为你自动配置。
当满足以下条件时，控制台会自动配置：

* 你正在开发基于 Servlet 的 Web 应用程序。
* `com.h2database:h2` 在类路径上。
* 你正在使用 xref:using/devtools.adoc[Spring Boot 的开发工具]。

TIP: 如果你不使用 Spring Boot 的开发工具，但仍希望使用 H2 的控制台，可以将 configprop:spring.h2.console.enabled[] 属性配置为 `true`。

NOTE: H2 控制台仅用于开发期间，因此请确保在生产环境中不要将 `spring.h2.console.enabled` 设置为 `true`。

[[data.sql.h2-web-console.custom-path]]
=== 更改 H2 控制台的路径
默认情况下，控制台在 `/h2-console` 可用。
你可以使用 configprop:spring.h2.console.path[] 属性自定义控制台的路径。

[[data.sql.h2-web-console.spring-security]]
=== 在安全应用程序中访问 H2 控制台
H2 控制台使用框架，并且由于它仅用于开发，因此未实现 CSRF 保护措施。
如果你的应用程序使用 Spring Security，则需要配置它以

* 禁用对控制台请求的 CSRF 保护，
* 在控制台的响应中设置 `X-Frame-Options` 标头为 `SAMEORIGIN`。

有关 {url-spring-security-docs}/features/exploits/csrf.html[CSRF] 和 {url-spring-security-docs}/features/exploits/headers.html#headers-frame-options[X-Frame-Options] 标头的更多信息，请参阅 Spring Security 参考指南。

在简单设置中，可以使用如下所示的 javadoc:org.springframework.security.web.SecurityFilterChain[]：

include-code::DevProfileSecurityConfiguration[tag=!customizer]

WARNING: H2 控制台仅用于开发期间。
在生产环境中，禁用 CSRF 保护或允许网站使用框架可能会造成严重的安全风险。

TIP: `PathRequest.toH2Console()` 在控制台路径已自定义时也会返回正确的请求匹配器。

[[data.sql.jooq]]
== 使用 jOOQ
jOOQ 面向对象查询（https://www.jooq.org/[jOOQ]）是 https://www.datageekery.com/[Data Geekery] 的一个流行产品，它从你的数据库生成 Java 代码，并通过其流畅的 API 构建类型安全的 SQL 查询。
商业版和开源版都可以与 Spring Boot 一起使用。

[[data.sql.jooq.codegen]]
=== 代码生成
为了使用 jOOQ 类型安全的查询，你需要从数据库模式生成 Java 类。
你可以按照 {url-jooq-docs}/#jooq-in-7-steps-step3[jOOQ 用户手册] 中的说明进行操作。
如果你使用 `jooq-codegen-maven` 插件，并且还使用 `spring-boot-starter-parent`“父 POM”，则可以安全地省略插件的 `<version>` 标签。
你还可以使用 Spring Boot 定义的版本变量（例如 `h2.version`）来声明插件的数据库依赖项。
以下清单显示了一个示例：

[source,xml]
----
<plugin>
	<groupId>org.jooq</groupId>
	<artifactId>jooq-codegen-maven</artifactId>
	<executions>
		...
	</executions>
	<dependencies>
		<dependency>
			<groupId>com.h2database</groupId>
			<artifactId>h2</artifactId>
			<version>${h2.version}</version>
		</dependency>
	</dependencies>
	<configuration>
		<jdbc>
			<driver>org.h2.Driver</driver>
			<url>jdbc:h2:~/yourdatabase</url>
		</jdbc>
		<generator>
			...
		</generator>
	</configuration>
</plugin>
----

[[data.sql.jooq.dslcontext]]
=== 使用 DSLContext
jOOQ 提供的流畅 API 通过 javadoc:org.jooq.DSLContext[] 接口启动。
Spring Boot 自动配置一个 javadoc:org.jooq.DSLContext[] 作为 Spring Bean，并将其连接到你的应用程序 javadoc:javax.sql.DataSource[]。
要使用 javadoc:org.jooq.DSLContext[]，你可以将其注入，如下例所示：

include-code::MyBean[tag=!method]

TIP: jOOQ 手册倾向于使用名为 `create` 的变量来保存 javadoc:org.jooq.DSLContext[]。

然后，你可以使用 javadoc:org.jooq.DSLContext[] 构建查询，如下例所示：

include-code::MyBean[tag=method]

[[data.sql.jooq.sqldialect]]
=== jOOQ SQL 方言
除非配置了 configprop:spring.jooq.sql-dialect[] 属性，否则 Spring Boot 会确定用于数据源的 SQL 方言。
如果 Spring Boot 无法检测到方言，则使用 `DEFAULT`。

NOTE: Spring Boot 只能自动配置 jOOQ 开源版本支持的方言。

[[data.sql.jooq.customizing]]
=== 自定义 jOOQ
可以通过定义你自己的 javadoc:org.springframework.boot.autoconfigure.jooq.DefaultConfigurationCustomizer[] bean 来实现更高级的自定义，该 bean 将在创建 javadoc:org.jooq.Configuration[] javadoc:org.springframework.context.annotation.Bean[format=annotation] 之前调用。
这优先于自动配置应用的任何内容。

你还可以创建自己的 javadoc:org.jooq.Configuration[] javadoc:org.springframework.context.annotation.Bean[format=annotation]，如果你希望完全控制 jOOQ 配置。

[[data.sql.r2dbc]]
== 使用 R2DBC
Reactive Relational Database Connectivity（https://r2dbc.io[R2DBC]）项目为关系数据库带来了响应式编程 API。
R2DBC 的 javadoc:io.r2dbc.spi.Connection[] 提供了一种与无阻塞数据库连接交互的标准方法。
连接通过使用 javadoc:io.r2dbc.spi.ConnectionFactory[] 提供，类似于使用 JDBC 的 javadoc:javax.sql.DataSource[]。

javadoc:io.r2dbc.spi.ConnectionFactory[] 配置由 `+spring.r2dbc.*+` 中的外部配置属性控制。
例如，你可以在 `application.properties` 中声明以下部分：

[configprops,yaml]
----
spring:
  r2dbc:
    url: "r2dbc:postgresql://localhost/test"
    username: "dbuser"
    password: "dbpass"
----

TIP: 你不需要指定驱动程序类名称，因为 Spring Boot 会从 R2DBC 的 Connection Factory 发现中获取驱动程序。

NOTE: 至少应提供 URL。
URL 中指定的信息优先于各个属性，即 `name`、`username`、`password` 和池化选项。

TIP: “操作指南”部分包含一个关于 xref:how-to:data-initialization.adoc#howto.data-initialization.using-basic-sql-scripts[如何使用基本 SQL 脚本初始化数据库] 的部分。

要自定义由 javadoc:io.r2dbc.spi.ConnectionFactory[] 创建的连接，即设置你不希望（或无法）在中央数据库配置中配置的特定参数，你可以使用 javadoc:org.springframework.boot.autoconfigure.r2dbc.ConnectionFactoryOptionsBuilderCustomizer[] javadoc:org.springframework.context.annotation.Bean[format=annotation]。
以下示例显示了如何手动覆盖数据库端口，而其余选项取自应用程序配置：

include-code::MyR2dbcConfiguration[]

以下示例显示了如何设置一些 PostgreSQL 连接选项：

include-code::MyPostgresR2dbcConfiguration[]

当 javadoc:io.r2dbc.spi.ConnectionFactory[] bean 可用时，常规的 JDBC javadoc:javax.sql.DataSource[] 自动配置会回退。
如果你希望保留 JDBC javadoc:javax.sql.DataSource[] 自动配置，并且愿意在响应式应用程序中使用阻塞的 JDBC API 的风险，请在应用程序中的 javadoc:org.springframework.context.annotation.Configuration[format=annotation] 类上添加 `@Import(DataSourceAutoConfiguration.class)` 以重新启用它。

[[data.sql.r2dbc.embedded]]
=== 嵌入式数据库支持
类似于 xref:data/sql.adoc#data.sql.datasource.embedded[JDBC 支持]，Spring Boot 可以自动配置嵌入式数据库以用于响应式使用。
你不需要提供任何连接 URL。
你只需包含要使用的嵌入式数据库的构建依赖项，如下例所示：

[source,xml]
----
<dependency>
	<groupId>io.r2dbc</groupId>
	<artifactId>r2dbc-h2</artifactId>
	<scope>runtime</scope>
</dependency>
----

[NOTE]
====
如果你在测试中使用此功能，你可能会注意到，无论使用多少个应用程序上下文，整个测试套件都会重用同一个数据库。
如果你希望确保每个上下文都有一个单独的嵌入式数据库，应将 `spring.r2dbc.generate-unique-name` 设置为 `true`。
====

[[data.sql.r2dbc.using-database-client]]
=== 使用 DatabaseClient
自动配置了一个 javadoc:org.springframework.r2dbc.core.DatabaseClient[] bean，你可以直接将其自动注入到你自己的 bean 中，如下例所示：

include-code::MyBean[]

[[data.sql.r2dbc.repositories]]
=== Spring Data R2DBC 存储库
https://spring.io/projects/spring-data-r2dbc[Spring Data R2DBC] 存储库是你可以定义以访问数据的接口。
查询会自动从你的方法名称创建。
例如，`CityRepository` 接口可能会声明一个 `findAllByState(String state)` 方法，以查找给定州的所有城市。

对于更复杂的查询，你可以使用 Spring Data 的 javadoc:org.springframework.data.r2dbc.repository.Query[format=annotation] 注解来注解你的方法。

Spring Data 存储库通常扩展自 javadoc:org.springframework.data.repository.Repository[] 或 javadoc:org.springframework.data.repository.CrudRepository[] 接口。
如果使用自动配置，则会在 xref:using/auto-configuration.adoc#using.auto-configuration.packages[自动配置包] 中搜索存储库。

以下示例显示了一个典型的 Spring Data 存储库接口定义：

include-code::CityRepository[]

TIP: 我们只是浅尝辄止地介绍了 Spring Data R2DBC。有关完整详细信息，请参阅 {url-spring-data-r2dbc-docs}[Spring Data R2DBC 参考文档]。

'''
[[data.sql]]
== SQL Databases
The {url-spring-framework-site}[Spring Framework] provides extensive support for working with SQL databases, from direct JDBC access using javadoc:org.springframework.jdbc.core.simple.JdbcClient[] or javadoc:org.springframework.jdbc.core.JdbcTemplate[] to complete "`object relational mapping`" technologies such as Hibernate.
{url-spring-data-site}[Spring Data] provides an additional level of functionality: creating javadoc:org.springframework.data.repository.Repository[] implementations directly from interfaces and using conventions to generate queries from your method names.

[[data.sql.datasource]]
== Configure a DataSource
Java's javadoc:javax.sql.DataSource[] interface provides a standard method of working with database connections.
Traditionally, a javadoc:javax.sql.DataSource[] uses a `URL` along with some credentials to establish a database connection.

TIP: See the xref:how-to:data-access.adoc#howto.data-access.configure-custom-datasource[] section of the "`How-to Guides`" for more advanced examples, typically to take full control over the configuration of the DataSource.

[[data.sql.datasource.embedded]]
=== Embedded Database Support
It is often convenient to develop applications by using an in-memory embedded database.
Obviously, in-memory databases do not provide persistent storage.
You need to populate your database when your application starts and be prepared to throw away data when your application ends.

TIP: The "`How-to Guides`" section includes a xref:how-to:data-initialization.adoc[section on how to initialize a database].

Spring Boot can auto-configure embedded https://www.h2database.com[H2], https://hsqldb.org/[HSQL], and https://db.apache.org/derby/[Derby] databases.
You need not provide any connection URLs.
You need only include a build dependency to the embedded database that you want to use.
If there are multiple embedded databases on the classpath, set the configprop:spring.datasource.embedded-database-connection[] configuration property to control which one is used.
Setting the property to `none` disables auto-configuration of an embedded database.

[NOTE]
====
If you are using this feature in your tests, you may notice that the same database is reused by your whole test suite regardless of the number of application contexts that you use.
If you want to make sure that each context has a separate embedded database, you should set `spring.datasource.generate-unique-name` to `true`.
====

For example, the typical POM dependencies would be as follows:

[source,xml]
----
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>
<dependency>
	<groupId>org.hsqldb</groupId>
	<artifactId>hsqldb</artifactId>
	<scope>runtime</scope>
</dependency>
----

NOTE: You need a dependency on `spring-jdbc` for an embedded database to be auto-configured.
In this example, it is pulled in transitively through `spring-boot-starter-data-jpa`.

TIP: If, for whatever reason, you do configure the connection URL for an embedded database, take care to ensure that the database's automatic shutdown is disabled.
If you use H2, you should use `DB_CLOSE_ON_EXIT=FALSE` to do so.
If you use HSQLDB, you should ensure that `shutdown=true` is not used.
Disabling the database's automatic shutdown lets Spring Boot control when the database is closed, thereby ensuring that it happens once access to the database is no longer needed.

[[data.sql.datasource.production]]
=== Connection to a Production Database
Production database connections can also be auto-configured by using a pooling javadoc:javax.sql.DataSource[].

[[data.sql.datasource.configuration]]
=== DataSource Configuration
DataSource configuration is controlled by external configuration properties in `+spring.datasource.*+`.
For example, you might declare the following section in `application.properties`:

[configprops,yaml]
----
spring:
  datasource:
    url: "jdbc:mysql://localhost/test"
    username: "dbuser"
    password: "dbpass"
----

NOTE: You should at least specify the URL by setting the configprop:spring.datasource.url[] property.
Otherwise, Spring Boot tries to auto-configure an embedded database.

TIP: Spring Boot can deduce the JDBC driver class for most databases from the URL.
If you need to specify a specific class, you can use the configprop:spring.datasource.driver-class-name[] property.

NOTE: For a pooling javadoc:javax.sql.DataSource[] to be created, we need to be able to verify that a valid javadoc:java.sql.Driver[] class is available, so we check for that before doing anything.
In other words, if you set `spring.datasource.driver-class-name=com.mysql.jdbc.Driver`, then that class has to be loadable.

See javadoc:org.springframework.boot.autoconfigure.jdbc.DataSourceProperties[] API documentation for more of the supported options.
These are the standard options that work regardless of xref:data/sql.adoc#data.sql.datasource.connection-pool[the actual implementation].
It is also possible to fine-tune implementation-specific settings by using their respective prefix (`+spring.datasource.hikari.*+`, `+spring.datasource.tomcat.*+`, `+spring.datasource.dbcp2.*+`, and `+spring.datasource.oracleucp.*+`).
See the documentation of the connection pool implementation you are using for more details.

For instance, if you use the {url-tomcat-docs}/jdbc-pool.html#Common_Attributes[Tomcat connection pool], you could customize many additional settings, as shown in the following example:

[configprops,yaml]
----
spring:
  datasource:
    tomcat:
      max-wait: 10000
      max-active: 50
      test-on-borrow: true
----

This will set the pool to wait 10000ms before throwing an exception if no connection is available, limit the maximum number of connections to 50 and validate the connection before borrowing it from the pool.

[[data.sql.datasource.connection-pool]]
=== Supported Connection Pools
Spring Boot uses the following algorithm for choosing a specific implementation:

. We prefer https://github.com/brettwooldridge/HikariCP[HikariCP] for its performance and concurrency.
If HikariCP is available, we always choose it.
. Otherwise, if the Tomcat pooling javadoc:javax.sql.DataSource[] is available, we use it.
. Otherwise, if https://commons.apache.org/proper/commons-dbcp/[Commons DBCP2] is available, we use it.
. If none of HikariCP, Tomcat, and DBCP2 are available and if Oracle UCP is available, we use it.

NOTE: If you use the `spring-boot-starter-jdbc` or `spring-boot-starter-data-jpa` starters, you automatically get a dependency to HikariCP.

You can bypass that algorithm completely and specify the connection pool to use by setting the configprop:spring.datasource.type[] property.
This is especially important if you run your application in a Tomcat container, as `tomcat-jdbc` is provided by default.

Additional connection pools can always be configured manually, using javadoc:org.springframework.boot.jdbc.DataSourceBuilder[].
If you define your own javadoc:javax.sql.DataSource[] bean, auto-configuration does not occur.
The following connection pools are supported by javadoc:org.springframework.boot.jdbc.DataSourceBuilder[]:

* HikariCP
* Tomcat pooling javadoc:javax.sql.DataSource[]
* Commons DBCP2
* Oracle UCP & `OracleDataSource`
* Spring Framework's javadoc:org.springframework.jdbc.datasource.SimpleDriverDataSource[]
* H2 javadoc:org.h2.jdbcx.JdbcDataSource[]
* PostgreSQL javadoc:org.postgresql.ds.PGSimpleDataSource[]
* C3P0

[[data.sql.datasource.jndi]]
=== Connection to a JNDI DataSource
If you deploy your Spring Boot application to an Application Server, you might want to configure and manage your DataSource by using your Application Server's built-in features and access it by using JNDI.

The configprop:spring.datasource.jndi-name[] property can be used as an alternative to the configprop:spring.datasource.url[], configprop:spring.datasource.username[], and configprop:spring.datasource.password[] properties to access the javadoc:javax.sql.DataSource[] from a specific JNDI location.
For example, the following section in `application.properties` shows how you can access a JBoss AS defined javadoc:javax.sql.DataSource[]:

[configprops,yaml]
----
spring:
  datasource:
    jndi-name: "java:jboss/datasources/customers"
----

[[data.sql.jdbc-template]]
== Using JdbcTemplate
Spring's javadoc:org.springframework.jdbc.core.JdbcTemplate[] and javadoc:org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate[] classes are auto-configured, and you can autowire them directly into your own beans, as shown in the following example:

include-code::MyBean[]

You can customize some properties of the template by using the `spring.jdbc.template.*` properties, as shown in the following example:

[configprops,yaml]
----
spring:
  jdbc:
    template:
      max-rows: 500
----

NOTE: The javadoc:org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate[] reuses the same javadoc:org.springframework.jdbc.core.JdbcTemplate[] instance behind the scenes.
If more than one javadoc:org.springframework.jdbc.core.JdbcTemplate[] is defined and no primary candidate exists, the javadoc:org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate[] is not auto-configured.

[[data.sql.jdbc-client]]
== Using JdbcClient
Spring's javadoc:org.springframework.jdbc.core.simple.JdbcClient[] is auto-configured based on the presence of a javadoc:org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate[].
You can inject it directly in your own beans as well, as shown in the following example:

include-code::MyBean[]

If you rely on auto-configuration to create the underlying javadoc:org.springframework.jdbc.core.JdbcTemplate[], any customization using `spring.jdbc.template.*` properties is taken into account in the client as well.

[[data.sql.jpa-and-spring-data]]
== JPA and Spring Data JPA
The Java Persistence API is a standard technology that lets you "`map`" objects to relational databases.
The `spring-boot-starter-data-jpa` POM provides a quick way to get started.
It provides the following key dependencies:

* Hibernate: One of the most popular JPA implementations.
* Spring Data JPA: Helps you to implement JPA-based repositories.
* Spring ORM: Core ORM support from the Spring Framework.

TIP: We do not go into too many details of JPA or {url-spring-data-site}[Spring Data] here.
You can follow the https://spring.io/guides/gs/accessing-data-jpa/[Accessing Data with JPA] guide from https://spring.io and read the {url-spring-data-jpa-site}[Spring Data JPA] and https://hibernate.org/orm/documentation/[Hibernate] reference documentation.

[[data.sql.jpa-and-spring-data.entity-classes]]
=== Entity Classes
Traditionally, JPA "`Entity`" classes are specified in a `persistence.xml` file.
With Spring Boot, this file is not necessary and "`Entity Scanning`" is used instead.
By default the xref:using/auto-configuration.adoc#using.auto-configuration.packages[auto-configuration packages] are scanned.

Any classes annotated with javadoc:jakarta.persistence.Entity[format=annotation], javadoc:jakarta.persistence.Embeddable[format=annotation], or javadoc:jakarta.persistence.MappedSuperclass[format=annotation] are considered.
A typical entity class resembles the following example:

include-code::City[]

TIP: You can customize entity scanning locations by using the javadoc:org.springframework.boot.autoconfigure.domain.EntityScan[format=annotation] annotation.
See the xref:how-to:data-access.adoc#howto.data-access.separate-entity-definitions-from-spring-configuration[] section of the "`How-to Guides`".

[[data.sql.jpa-and-spring-data.repositories]]
=== Spring Data JPA Repositories
{url-spring-data-jpa-site}[Spring Data JPA] repositories are interfaces that you can define to access data.
JPA queries are created automatically from your method names.
For example, a `CityRepository` interface might declare a `findAllByState(String state)` method to find all the cities in a given state.

For more complex queries, you can annotate your method with Spring Data's javadoc:org.springframework.data.jpa.repository.Query[] annotation.

Spring Data repositories usually extend from the javadoc:org.springframework.data.repository.Repository[] or javadoc:org.springframework.data.repository.CrudRepository[] interfaces.
If you use auto-configuration, the xref:using/auto-configuration.adoc#using.auto-configuration.packages[auto-configuration packages] are searched for repositories.

TIP: You can customize the locations to look for repositories using javadoc:org.springframework.data.jpa.repository.config.EnableJpaRepositories[format=annotation].

The following example shows a typical Spring Data repository interface definition:

include-code::CityRepository[]

Spring Data JPA repositories support three different modes of bootstrapping: default, deferred, and lazy.
To enable deferred or lazy bootstrapping, set the configprop:spring.data.jpa.repositories.bootstrap-mode[] property to `deferred` or `lazy` respectively.
When using deferred or lazy bootstrapping, the auto-configured javadoc:org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder[] will use the context's javadoc:org.springframework.core.task.AsyncTaskExecutor[], if any, as the bootstrap executor.
If more than one exists, the one named `applicationTaskExecutor` will be used.

[NOTE]
====
When using deferred or lazy bootstrapping, make sure to defer any access to the JPA infrastructure after the application context bootstrap phase.
You can use javadoc:org.springframework.beans.factory.SmartInitializingSingleton[] to invoke any initialization that requires the JPA infrastructure.
For JPA components (such as converters) that are created as Spring beans, use javadoc:org.springframework.beans.factory.ObjectProvider[] to delay the resolution of dependencies, if any.
====

TIP: We have barely scratched the surface of Spring Data JPA.
For complete details, see the {url-spring-data-jpa-docs}[Spring Data JPA reference documentation].

[[data.sql.jpa-and-spring-data.envers-repositories]]
=== Spring Data Envers Repositories
If {url-spring-data-envers-site}[Spring Data Envers] is available, JPA repositories are auto-configured to support typical Envers queries.

To use Spring Data Envers, make sure your repository extends from javadoc:org.springframework.data.repository.history.RevisionRepository[] as shown in the following example:

include-code::CountryRepository[]

NOTE: For more details, check the {url-spring-data-jpa-docs}/envers.html[Spring Data Envers reference documentation].

[[data.sql.jpa-and-spring-data.creating-and-dropping]]
=== Creating and Dropping JPA Databases
By default, JPA databases are automatically created *only* if you use an embedded database (H2, HSQL, or Derby).
You can explicitly configure JPA settings by using `+spring.jpa.*+` properties.
For example, to create and drop tables you can add the following line to your `application.properties`:

[configprops,yaml]
----
spring:
  jpa:
    hibernate.ddl-auto: "create-drop"
----

NOTE: Hibernate's own internal property name for this (if you happen to remember it better) is `hibernate.hbm2ddl.auto`.
You can set it, along with other Hibernate native properties, by using `+spring.jpa.properties.*+` (the prefix is stripped before adding them to the entity manager).
The following line shows an example of setting JPA properties for Hibernate:

[configprops,yaml]
----
spring:
  jpa:
    properties:
      hibernate:
        "globally_quoted_identifiers": "true"
----

The line in the preceding example passes a value of `true` for the `hibernate.globally_quoted_identifiers` property to the Hibernate entity manager.

By default, the DDL execution (or validation) is deferred until the javadoc:org.springframework.context.ApplicationContext[] has started.

[[data.sql.jpa-and-spring-data.open-entity-manager-in-view]]
=== Open EntityManager in View
If you are running a web application, Spring Boot by default registers javadoc:org.springframework.orm.jpa.support.OpenEntityManagerInViewInterceptor[] to apply the "`Open EntityManager in View`" pattern, to allow for lazy loading in web views.
If you do not want this behavior, you should set `spring.jpa.open-in-view` to `false` in your `application.properties`.

[[data.sql.jdbc]]
== Spring Data JDBC
Spring Data includes repository support for JDBC and will automatically generate SQL for the methods on javadoc:org.springframework.data.repository.CrudRepository[].
For more advanced queries, a javadoc:org.springframework.data.jdbc.repository.query.Query[format=annotation] annotation is provided.

Spring Boot will auto-configure Spring Data's JDBC repositories when the necessary dependencies are on the classpath.
They can be added to your project with a single dependency on `spring-boot-starter-data-jdbc`.
If necessary, you can take control of Spring Data JDBC's configuration by adding the javadoc:org.springframework.data.jdbc.repository.config.EnableJdbcRepositories[format=annotation] annotation or an javadoc:org.springframework.data.jdbc.repository.config.AbstractJdbcConfiguration[] subclass to your application.

TIP: For complete details of Spring Data JDBC, see the {url-spring-data-jdbc-docs}[reference documentation].

[[data.sql.h2-web-console]]
== Using H2's Web Console
The https://www.h2database.com[H2 database] provides a https://www.h2database.com/html/quickstart.html#h2_console[browser-based console] that Spring Boot can auto-configure for you.
The console is auto-configured when the following conditions are met:

* You are developing a servlet-based web application.
* `com.h2database:h2` is on the classpath.
* You are using xref:using/devtools.adoc[Spring Boot's developer tools].

TIP: If you are not using Spring Boot's developer tools but would still like to make use of H2's console, you can configure the configprop:spring.h2.console.enabled[] property with a value of `true`.

NOTE: The H2 console is only intended for use during development, so you should take care to ensure that `spring.h2.console.enabled` is not set to `true` in production.

[[data.sql.h2-web-console.custom-path]]
=== Changing the H2 Console's Path
By default, the console is available at `/h2-console`.
You can customize the console's path by using the configprop:spring.h2.console.path[] property.

[[data.sql.h2-web-console.spring-security]]
=== Accessing the H2 Console in a Secured Application
H2 Console uses frames and, as it is intended for development only, does not implement CSRF protection measures.
If your application uses Spring Security, you need to configure it to

* disable CSRF protection for requests against the console,
* set the header `X-Frame-Options` to `SAMEORIGIN` on responses from the console.

More information on {url-spring-security-docs}/features/exploits/csrf.html[CSRF] and the header {url-spring-security-docs}/features/exploits/headers.html#headers-frame-options[X-Frame-Options] can be found in the Spring Security Reference Guide.

In simple setups, a javadoc:org.springframework.security.web.SecurityFilterChain[] like the following can be used:

include-code::DevProfileSecurityConfiguration[tag=!customizer]

WARNING: The H2 console is only intended for use during development.
In production, disabling CSRF protection or allowing frames for a website may create severe security risks.

TIP: `PathRequest.toH2Console()` returns the correct request matcher also when the console's path has been customized.

[[data.sql.jooq]]
== Using jOOQ
jOOQ Object Oriented Querying (https://www.jooq.org/[jOOQ]) is a popular product from https://www.datageekery.com/[Data Geekery] which generates Java code from your database and lets you build type-safe SQL queries through its fluent API.
Both the commercial and open source editions can be used with Spring Boot.

[[data.sql.jooq.codegen]]
=== Code Generation
In order to use jOOQ type-safe queries, you need to generate Java classes from your database schema.
You can follow the instructions in the {url-jooq-docs}/#jooq-in-7-steps-step3[jOOQ user manual].
If you use the `jooq-codegen-maven` plugin and you also use the `spring-boot-starter-parent` "`parent POM`", you can safely omit the plugin's `<version>` tag.
You can also use Spring Boot-defined version variables (such as `h2.version`) to declare the plugin's database dependency.
The following listing shows an example:

[source,xml]
----
<plugin>
	<groupId>org.jooq</groupId>
	<artifactId>jooq-codegen-maven</artifactId>
	<executions>
		...
	</executions>
	<dependencies>
		<dependency>
			<groupId>com.h2database</groupId>
			<artifactId>h2</artifactId>
			<version>${h2.version}</version>
		</dependency>
	</dependencies>
	<configuration>
		<jdbc>
			<driver>org.h2.Driver</driver>
			<url>jdbc:h2:~/yourdatabase</url>
		</jdbc>
		<generator>
			...
		</generator>
	</configuration>
</plugin>
----

[[data.sql.jooq.dslcontext]]
=== Using DSLContext
The fluent API offered by jOOQ is initiated through the javadoc:org.jooq.DSLContext[] interface.
Spring Boot auto-configures a javadoc:org.jooq.DSLContext[] as a Spring Bean and connects it to your application javadoc:javax.sql.DataSource[].
To use the javadoc:org.jooq.DSLContext[], you can inject it, as shown in the following example:

include-code::MyBean[tag=!method]

TIP: The jOOQ manual tends to use a variable named `create` to hold the javadoc:org.jooq.DSLContext[].

You can then use the javadoc:org.jooq.DSLContext[] to construct your queries, as shown in the following example:

include-code::MyBean[tag=method]

[[data.sql.jooq.sqldialect]]
=== jOOQ SQL Dialect
Unless the configprop:spring.jooq.sql-dialect[] property has been configured, Spring Boot determines the SQL dialect to use for your datasource.
If Spring Boot could not detect the dialect, it uses `DEFAULT`.

NOTE: Spring Boot can only auto-configure dialects supported by the open source version of jOOQ.

[[data.sql.jooq.customizing]]
=== Customizing jOOQ
More advanced customizations can be achieved by defining your own javadoc:org.springframework.boot.autoconfigure.jooq.DefaultConfigurationCustomizer[] bean that will be invoked prior to creating the javadoc:org.jooq.Configuration[] javadoc:org.springframework.context.annotation.Bean[format=annotation].
This takes precedence to anything that is applied by the auto-configuration.

You can also create your own javadoc:org.jooq.Configuration[] javadoc:org.springframework.context.annotation.Bean[format=annotation] if you want to take complete control of the jOOQ configuration.

[[data.sql.r2dbc]]
== Using R2DBC
The Reactive Relational Database Connectivity (https://r2dbc.io[R2DBC]) project brings reactive programming APIs to relational databases.
R2DBC's javadoc:io.r2dbc.spi.Connection[] provides a standard method of working with non-blocking database connections.
Connections are provided by using a javadoc:io.r2dbc.spi.ConnectionFactory[], similar to a javadoc:javax.sql.DataSource[] with jdbc.

javadoc:io.r2dbc.spi.ConnectionFactory[] configuration is controlled by external configuration properties in `+spring.r2dbc.*+`.
For example, you might declare the following section in `application.properties`:

[configprops,yaml]
----
spring:
  r2dbc:
    url: "r2dbc:postgresql://localhost/test"
    username: "dbuser"
    password: "dbpass"
----

TIP: You do not need to specify a driver class name, since Spring Boot obtains the driver from R2DBC's Connection Factory discovery.

NOTE: At least the url should be provided.
Information specified in the URL takes precedence over individual properties, that is `name`, `username`, `password` and pooling options.

TIP: The "`How-to Guides`" section includes a xref:how-to:data-initialization.adoc#howto.data-initialization.using-basic-sql-scripts[section on how to initialize a database].

To customize the connections created by a javadoc:io.r2dbc.spi.ConnectionFactory[], that is, set specific parameters that you do not want (or cannot) configure in your central database configuration, you can use a javadoc:org.springframework.boot.autoconfigure.r2dbc.ConnectionFactoryOptionsBuilderCustomizer[] javadoc:org.springframework.context.annotation.Bean[format=annotation].
The following example shows how to manually override the database port while the rest of the options are taken from the application configuration:

include-code::MyR2dbcConfiguration[]

The following examples show how to set some PostgreSQL connection options:

include-code::MyPostgresR2dbcConfiguration[]

When a javadoc:io.r2dbc.spi.ConnectionFactory[] bean is available, the regular JDBC javadoc:javax.sql.DataSource[] auto-configuration backs off.
If you want to retain the JDBC javadoc:javax.sql.DataSource[] auto-configuration, and are comfortable with the risk of using the blocking JDBC API in a reactive application, add `@Import(DataSourceAutoConfiguration.class)` on a javadoc:org.springframework.context.annotation.Configuration[format=annotation] class in your application to re-enable it.

[[data.sql.r2dbc.embedded]]
=== Embedded Database Support
Similarly to xref:data/sql.adoc#data.sql.datasource.embedded[the JDBC support], Spring Boot can automatically configure an embedded database for reactive usage.
You need not provide any connection URLs.
You need only include a build dependency to the embedded database that you want to use, as shown in the following example:

[source,xml]
----
<dependency>
	<groupId>io.r2dbc</groupId>
	<artifactId>r2dbc-h2</artifactId>
	<scope>runtime</scope>
</dependency>
----

[NOTE]
====
If you are using this feature in your tests, you may notice that the same database is reused by your whole test suite regardless of the number of application contexts that you use.
If you want to make sure that each context has a separate embedded database, you should set `spring.r2dbc.generate-unique-name` to `true`.
====

[[data.sql.r2dbc.using-database-client]]
=== Using DatabaseClient
A javadoc:org.springframework.r2dbc.core.DatabaseClient[] bean is auto-configured, and you can autowire it directly into your own beans, as shown in the following example:

include-code::MyBean[]

[[data.sql.r2dbc.repositories]]
=== Spring Data R2DBC Repositories
https://spring.io/projects/spring-data-r2dbc[Spring Data R2DBC] repositories are interfaces that you can define to access data.
Queries are created automatically from your method names.
For example, a `CityRepository` interface might declare a `findAllByState(String state)` method to find all the cities in a given state.

For more complex queries, you can annotate your method with Spring Data's javadoc:org.springframework.data.r2dbc.repository.Query[format=annotation] annotation.

Spring Data repositories usually extend from the javadoc:org.springframework.data.repository.Repository[] or javadoc:org.springframework.data.repository.CrudRepository[] interfaces.
If you use auto-configuration, the xref:using/auto-configuration.adoc#using.auto-configuration.packages[auto-configuration packages] are searched for repositories.

The following example shows a typical Spring Data repository interface definition:

include-code::CityRepository[]

TIP: We have barely scratched the surface of Spring Data R2DBC. For complete details, see the {url-spring-data-r2dbc-docs}[Spring Data R2DBC reference documentation].