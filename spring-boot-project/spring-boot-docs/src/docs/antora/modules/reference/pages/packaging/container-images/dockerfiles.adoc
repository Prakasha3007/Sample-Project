= Dockerfiles
:encoding: utf-8
:numbered:

[[packaging.container-images.dockerfiles]]
== Dockerfiles

虽然只需在 `Dockerfile` 中编写几行代码即可将 Spring Boot 的 uber jar 转换为 Docker 镜像，但使用 xref:packaging/container-images/efficient-images.adoc#packaging.container-images.efficient-images.layering[分层功能] 将生成一个优化的镜像。当你创建一个包含分层索引文件的 jar 时，`spring-boot-jarmode-tools` jar 将作为依赖项添加到你的 jar 中。有了这个 jar 在类路径上，你可以以特殊模式启动你的应用程序，该模式允许引导代码运行与你的应用程序完全不同的东西，例如提取层的内容。

NOTE: `tools` 模式不能与包含启动脚本的 xref:how-to:deployment/installing.adoc[完全可执行的 Spring Boot 存档] 一起使用。在构建用于 `layertools` 的 jar 文件时，请禁用启动脚本配置。

以下是如何使用 `tools` jar 模式启动你的 jar：

[source,shell]
----
$ java -Djarmode=tools -jar my-app.jar
----

这将提供以下输出：

[subs="verbatim"]
----
Usage:
  java -Djarmode=tools -jar my-app.jar

Available commands:
  extract      从 jar 中提取内容
  list-layers  列出可以从 jar 中提取的层
  help         获取有关任何命令的帮助
----

`extract` 命令可用于轻松将应用程序拆分为要添加到 `Dockerfile` 的层。以下是一个使用 `jarmode` 的 `Dockerfile` 示例。

[source,dockerfile]
----
include::reference:partial$dockerfile[]
# 启动应用程序 jar - 这不是构建器使用的 uber jar
# 此 jar 仅包含应用程序代码和对提取的 jar 文件的引用
# 这种布局启动高效且与 CDS 兼容
ENTRYPOINT ["java", "-jar", "application.jar"]
----

假设上述 `Dockerfile` 在当前目录中，你的 Docker 镜像可以使用 `docker build .` 构建，或者可以选择指定应用程序 jar 的路径，如下例所示：

[source,shell]
----
$ docker build --build-arg JAR_FILE=path/to/myapp.jar .
----

这是一个多阶段的 `Dockerfile`。构建器阶段提取稍后需要的目录。每个 `COPY` 命令都与 jarmode 提取的层相关。

当然，`Dockerfile` 可以在不使用 `jarmode` 的情况下编写。你可以使用 `unzip` 和 `mv` 的组合将内容移动到正确的层，但 `jarmode` 简化了这一过程。此外，`jarmode` 创建的布局开箱即用地与 CDS 兼容。

[[packaging.container-images.dockerfiles.cds]]
== CDS

如果你想额外启用 xref:reference:packaging/class-data-sharing.adoc[CDS]，你可以使用这个 `Dockerfile`：
[source,dockerfile]
----
include::reference:partial$dockerfile[]
# 执行 CDS 训练运行
RUN java -XX:ArchiveClassesAtExit=application.jsa -Dspring.context.exit=onRefresh -jar application.jar
# 启用 CDS 启动应用程序 jar - 这不是构建器使用的 uber jar
# 此 jar 仅包含应用程序代码和对提取的 jar 文件的引用
# 这种布局启动高效且与 CDS 兼容
ENTRYPOINT ["java", "-XX:SharedArchiveFile=application.jsa", "-jar", "application.jar"]
----

这与上面的 `Dockerfile` 基本相同。作为最后一步，它通过执行训练运行创建 CDS 存档，并将 CDS 参数传递给 `java -jar`。

'''
[[packaging.container-images.dockerfiles]]
== Dockerfiles
While it is possible to convert a Spring Boot uber jar into a Docker image with just a few lines in the `Dockerfile`, using the xref:packaging/container-images/efficient-images.adoc#packaging.container-images.efficient-images.layering[layering feature] will result in an optimized image.
When you create a jar containing the layers index file, the `spring-boot-jarmode-tools` jar will be added as a dependency to your jar.
With this jar on the classpath, you can launch your application in a special mode which allows the bootstrap code to run something entirely different from your application, for example, something that extracts the layers.

CAUTION: The `tools` mode can not be used with a xref:how-to:deployment/installing.adoc[fully executable Spring Boot archive] that includes a launch script.
Disable launch script configuration when building a jar file that is intended to be used with `layertools`.

Here’s how you can launch your jar with a `tools` jar mode:

[source,shell]
----
$ java -Djarmode=tools -jar my-app.jar
----

This will provide the following output:

[subs="verbatim"]
----
Usage:
  java -Djarmode=tools -jar my-app.jar

Available commands:
  extract      Extract the contents from the jar
  list-layers  List layers from the jar that can be extracted
  help         Help about any command
----

The `extract` command can be used to easily split the application into layers to be added to the `Dockerfile`.
Here is an example of a `Dockerfile` using `jarmode`.

[source,dockerfile]
----
include::reference:partial$dockerfile[]
# Start the application jar - this is not the uber jar used by the builder
# This jar only contains application code and references to the extracted jar files
# This layout is efficient to start up and CDS friendly
ENTRYPOINT ["java", "-jar", "application.jar"]
----

Assuming the above `Dockerfile` is in the current directory, your Docker image can be built with `docker build .`, or optionally specifying the path to your application jar, as shown in the following example:

[source,shell]
----
$ docker build --build-arg JAR_FILE=path/to/myapp.jar .
----

This is a multi-stage `Dockerfile`.
The builder stage extracts the directories that are needed later.
Each of the `COPY` commands relates to the layers extracted by the jarmode.

Of course, a `Dockerfile` can be written without using the `jarmode`.
You can use some combination of `unzip` and `mv` to move things to the right layer but `jarmode` simplifies that.
Additionally, the layout created by the `jarmode` is CDS friendly out of the box.

[[packaging.container-images.dockerfiles.cds]]
== CDS
If you want to additionally enable xref:reference:packaging/class-data-sharing.adoc[CDS], you can use this `Dockerfile`:
[source,dockerfile]
----
include::reference:partial$dockerfile[]
# Execute the CDS training run
RUN java -XX:ArchiveClassesAtExit=application.jsa -Dspring.context.exit=onRefresh -jar application.jar
# Start the application jar with CDS enabled - this is not the uber jar used by the builder
# This jar only contains application code and references to the extracted jar files
# This layout is efficient to start up and CDS friendly
ENTRYPOINT ["java", "-XX:SharedArchiveFile=application.jsa", "-jar", "application.jar"]
----

This is mostly the same as the above `Dockerfile`.
As the last steps, it creates the CDS archive by doing a training run and passes the CDS parameter to `java -jar`.

