= 打包可执行归档文件
:encoding: utf-8
:numbered:

[[packaging]]
== 打包可执行归档文件
该插件可以创建包含应用程序所有依赖项的可执行归档文件（jar 文件和 war 文件），然后可以使用 `java -jar` 运行。

打包可执行归档文件由 `repackage` 目标执行，如下例所示：

[source,xml,indent=0,subs="verbatim,attributes"]
----
include::example$packaging/repackage-pom.xml[tags=repackage]
----

WARNING: `repackage` 目标不意味着单独在命令行中使用，因为它操作的是 `package` 阶段生成的源 `jar`（或 `war`）。
要在命令行中使用此目标，必须包含 `package` 阶段：`mvn package spring-boot:repackage`。

TIP: 如果你使用 `spring-boot-starter-parent`，则此类执行已经预先配置了 `repackage` 执行 ID，因此只需添加插件定义。

上面的示例重新打包了在 Maven 生命周期的 `package` 阶段构建的 `jar` 或 `war` 归档文件，包括项目中定义的任何 `provided` 依赖项。
如果需要排除其中一些依赖项，可以使用 `exclude` 选项之一；有关更多详细信息，请参阅 xref:packaging.adoc#packaging.examples.exclude-dependency[依赖项排除]。

默认情况下，原始（即不可执行）工件被重命名为 `.original`，但也可以使用自定义分类器保留原始工件。

NOTE: 目前不支持 `maven-war-plugin` 的 `outputFileNameMapping` 功能。

默认情况下，`spring-boot-devtools` 和 `spring-boot-docker-compose` 模块会自动排除（你可以使用 `excludeDevtools` 和 `excludeDockerCompose` 属性来控制这一点）。
为了使其与 `war` 打包一起工作，`spring-boot-devtools` 和 `spring-boot-docker-compose` 依赖项必须设置为 `optional` 或 `provided` 范围。

该插件会重写你的清单，特别是它会管理 `Main-Class` 和 `Start-Class` 条目。
如果默认值不起作用，你必须在 Spring Boot 插件中配置这些值，而不是在 jar 插件中。
清单中的 `Main-Class` 由 Spring Boot 插件的 `layout` 属性控制，如下例所示：

[source,xml,indent=0,subs="verbatim,attributes"]
----
include::example$packaging/non-default-pom.xml[tags=non-default]
----

`layout` 属性默认为由归档类型（`jar` 或 `war`）确定的值。以下布局可用：

* `JAR`：常规的可执行 JAR 布局。
* `WAR`：可执行 WAR 布局。`provided` 依赖项放置在 `WEB-INF/lib-provided` 中，以避免在将 `war` 部署到 servlet 容器时发生冲突。
* `ZIP`（`DIR` 的别名）：类似于使用 `PropertiesLauncher` 的 `JAR` 布局。
* `NONE`：捆绑所有依赖项和项目资源。不捆绑引导加载程序。

[[packaging.layers]]
== 分层 Jar 或 War
重新打包的 jar 包含应用程序的类和依赖项，分别位于 `BOOT-INF/classes` 和 `BOOT-INF/lib` 中。
类似地，可执行的 war 包含应用程序的类在 `WEB-INF/classes` 中，依赖项在 `WEB-INF/lib` 和 `WEB-INF/lib-provided` 中。
对于需要从 jar 或 war 的内容构建 docker 镜像的情况，能够进一步分离这些目录以便将它们写入不同的层是很有用的。

分层归档使用与常规重新打包的 jar 或 war 相同的布局，但包含一个额外的元数据文件，用于描述每个层。

默认情况下，定义了以下层：

* `dependencies`：用于版本不包含 `SNAPSHOT` 的任何依赖项。
* `spring-boot-loader`：用于加载程序类。
* `snapshot-dependencies`：用于版本包含 `SNAPSHOT` 的任何依赖项。
* `application`：用于本地模块依赖项、应用程序类和资源。

模块依赖项通过查看当前构建中的所有模块来识别。
如果模块依赖项只能通过安装到 Maven 的本地缓存中来解决，并且它不是当前构建的一部分，则它将被识别为常规依赖项。

层的顺序很重要，因为它决定了当应用程序的一部分发生变化时，先前的层有多大可能被缓存。
默认顺序是 `dependencies`、`spring-boot-loader`、`snapshot-dependencies`、`application`。
最不可能更改的内容应首先添加，然后是更可能更改的层。

重新打包的归档默认包含 `layers.idx` 文件。
要禁用此功能，可以按以下方式进行：

[source,xml,indent=0,subs="verbatim,attributes"]
----
include::example$packaging/disable-layers-pom.xml[tags=disable-layers]
----

[[packaging.layers.configuration]]
=== 自定义层配置
根据你的应用程序，你可能希望调整层的创建方式并添加新层。
这可以通过使用单独的配置文件来完成，该文件应按如下方式注册：

[source,xml,indent=0,subs="verbatim,attributes"]
----
include::example$packaging/custom-layers-pom.xml[tags=custom-layers]
----

配置文件描述了如何将归档文件分离为层以及这些层的顺序。
以下示例展示了如何显式定义上述默认顺序：

[source,xml,indent=0,subs="verbatim,attributes"]
----
include::example$packaging/layers.xml[tags=layers]
----

`layers` XML 格式分为三个部分：

* `<application>` 块定义了应用程序类和资源应如何分层。
* `<dependencies>` 块定义了依赖项应如何分层。
* `<layerOrder>` 块定义了层的写入顺序。

在 `<application>` 和 `<dependencies>` 部分中，使用嵌套的 `<into>` 块来声明层的内容。
这些块按从上到下的定义顺序进行评估。
任何未被先前块声明的内容仍然可供后续块考虑。

`<into>` 块使用嵌套的 `<include>` 和 `<exclude>` 元素来声明内容。
`<application>` 部分使用 Ant 样式的路径匹配来进行包含/排除表达式。
`<dependencies>` 部分使用 `group:artifact[:version]` 模式。
它还提供了 `<includeModuleDependencies />` 和 `<excludeModuleDependencies />` 元素，可用于包含或排除本地模块依赖项。

如果未定义 `<include>`，则所有内容（未被先前块声明的内容）都会被考虑。

如果未定义 `<exclude>`，则不应用任何排除。

查看上面的 `<dependencies>` 示例，我们可以看到第一个 `<into>` 将为 `application.layer` 声明所有模块依赖项。
下一个 `<into>` 将为 `snapshot-dependencies` 层声明所有 SNAPSHOT 依赖项。
最后一个 `<into>` 将为 `dependencies` 层声明剩余的任何内容（在这种情况下，任何非 SNAPSHOT 的依赖项）。

`<application>` 块有类似的规则。
首先为 `spring-boot-loader` 层声明 `org/springframework/boot/loader/**` 内容。
然后为 `application` 层声明剩余的类和资源。

NOTE: `<into>` 块的定义顺序通常与层的写入顺序不同。
因此，必须始终包含 `<layerOrder>` 元素，并且 _必须_ 覆盖 `<into>` 块引用的所有层。

include::partial$goals/repackage.adoc[leveloffset=+1]

[[packaging.examples]]
== 示例

[[packaging.examples.custom-classifier]]
=== 自定义分类器
默认情况下，`repackage` 目标会用重新打包的工件替换原始工件。
这对于表示应用程序的模块来说是一个合理的行为，但如果你的模块用作另一个模块的依赖项，则需要为重新打包的工件提供一个分类器。
原因是应用程序类打包在 `BOOT-INF/classes` 中，因此依赖模块无法加载重新打包的 jar 的类。

如果是这种情况，或者如果你希望保留原始工件并使用不同的分类器附加重新打包的工件，请按如下方式配置插件：

[source,xml,indent=0,subs="verbatim,attributes"]
----
include::example$packaging/different-classifier-pom.xml[tags=different-classifier]
----

如果你使用 `spring-boot-starter-parent`，则 `repackage` 目标会在 ID 为 `repackage` 的执行中自动执行。
在这种情况下，只需指定配置，如下例所示：

[source,xml,indent=0,subs="verbatim,attributes"]
----
include::example$packaging/repackage-configuration-pom.xml[tags=repackage-configuration]
----

此配置将生成两个工件：原始工件和由 `repackage` 目标生成的重新打包的对应工件。
两者都将透明地安装/部署。

如果你希望以与主工件相同的方式重新打包次要工件，也可以使用相同的配置。
以下配置安装/部署一个带有重新打包应用程序的 `task` 分类工件：

[source,xml,indent=0,subs="verbatim,attributes"]
----
include::example$packaging/classified-artifact-pom.xml[tags=classified-artifact]
----

由于 `maven-jar-plugin` 和 `spring-boot-maven-plugin` 在同一阶段运行，因此重要的是首先定义 jar 插件（以便它在 `repackage` 目标之前运行）。
同样，如果你使用 `spring-boot-starter-parent`，则可以简化为以下内容：

[source,xml,indent=0,subs="verbatim,attributes"]
----
include::example$packaging/jar-plugin-first-pom.xml[tags=jar-plugin-first]
----

[[packaging.examples.custom-name]]
=== 自定义名称
如果需要重新打包的 jar 具有与项目的 `artifactId` 属性定义的名称不同的本地名称，请使用标准的 `finalName`，如下例所示：

[source,xml,indent=0,subs="verbatim,attributes"]
----
include::example$packaging/custom-name-pom.xml[tags=custom-name]
----

此配置将在 `target/my-app.jar` 中生成重新打包的工件。

[[packaging.examples.local-artifact]]
=== 本地重新打包的工件
默认情况下，`repackage` 目标会用可执行工件替换原始工件。
如果你只需要部署原始 jar 并且仍然能够使用常规文件名运行应用程序，请按如下方式配置插件：

[source,xml,indent=0,subs="verbatim,attributes"]
----
include::example$packaging/local-repackaged-artifact-pom.xml[tags=local-repackaged-artifact]
----

此配置生成两个工件：原始工件和由 `repackage` 目标生成的可执行对应工件。
只有原始工件会被安装/部署。

[[packaging.examples.custom-layout]]
=== 自定义布局
Spring Boot 使用构建插件提供的附加 jar 文件中定义的自定义布局工厂重新打包此项目的 jar 文件：

[source,xml,indent=0,subs="verbatim,attributes"]
----
include::example$packaging/custom-layout-pom.xml[tags=custom-layout]
----

布局工厂作为 `LayoutFactory`（来自 `spring-boot-loader-tools`）的实现提供，并在 pom 中明确指定。
如果插件类路径上只有一个自定义 `LayoutFactory` 并且它在 `META-INF/spring.factories` 中列出，则无需在插件配置中明确设置它。

如果设置了显式的 xref:#packaging.repackage-goal.parameter-details.layout-factory[布局]，则始终忽略布局工厂。

[[packaging.examples.exclude-dependency]]
=== 依赖项排除
默认情况下，`repackage` 和 `run` 目标都将包含项目中定义的任何 `provided` 依赖项。
Spring Boot 项目应将 `provided` 依赖项视为运行应用程序所需的“容器”依赖项。
一般来说，Spring Boot 项目不用作依赖项，因此不太可能具有任何 `optional` 依赖项。
当项目确实具有可选依赖项时，它们也将被 `repackage` 和 `run` 目标包含。

其中一些依赖项可能根本不需要，应从可执行 jar 中排除。
为了保持一致性，在运行应用程序时也不应存在这些依赖项。

有两种方法可以从打包/运行时使用的依赖项中排除依赖项：

* 排除由 `groupId` 和 `artifactId` 标识的特定工件，如果需要，还可以选择 `classifier`。
* 排除属于给定 `groupId` 的任何工件。

以下示例排除了 `com.example:module1`，并且仅排除该工件：

[source,xml,indent=0,subs="verbatim,attributes"]
----
include::example$packaging/exclude-artifact-pom.xml[tags=exclude-artifact]
----

此示例排除了属于 `com.example` 组的任何工件：

[source,xml,indent=0,subs="verbatim,attributes"]
----
include::example$packaging/exclude-artifact-group-pom.xml[tags=exclude-artifact-group]
----

[[packaging.examples.layered-archive-tools]]
=== JAR 工具
当创建分层 jar 或 war 时，`spring-boot-jarmode-tools` jar 将作为依赖项添加到你的归档中。
将此 jar 放在类路径上后，你可以以特殊模式启动应用程序，该模式允许引导代码运行与你的应用程序完全不同的内容，例如提取层的内容。
如果你希望排除此依赖项，可以按以下方式进行：

[source,xml,indent=0,subs="verbatim,attributes"]
----
include::example$packaging/exclude-dependency-pom.xml[tags=exclude-dependency]
----

[[packaging.examples.custom-layers-configuration]]
=== 自定义层配置
默认设置将依赖项分为快照和非快照，但你可能有更复杂的规则。
例如，你可能希望将项目的公司特定依赖项隔离在专用层中。
以下 `layers.xml` 配置展示了一种这样的设置：

[source,xml,indent=0,subs="verbatim,attributes"]
----
include::example$packaging/layers-configuration.xml[tags=layers-configuration]
----

上面的配置创建了一个额外的 `company-dependencies` 层，其中包含所有具有 `com.acme` groupId 的库。

'''
[[packaging]]
== Packaging Executable Archives
The plugin can create executable archives (jar files and war files) that contain all of an application's dependencies and can then be run with `java -jar`.

Packaging an executable archive is performed by the `repackage` goal, as shown in the following example:

[source,xml,indent=0,subs="verbatim,attributes"]
----
include::example$packaging/repackage-pom.xml[tags=repackage]
----

WARNING: The `repackage` goal is not meant to be used alone on the command-line as it operates on the source
`jar` (or `war`) produced by the `package` phase.
To use this goal on the command-line, you must include the `package` phase: `mvn package spring-boot:repackage`.

TIP: If you are using `spring-boot-starter-parent`, such execution is already pre-configured with a `repackage` execution ID so that only the plugin definition should be added.

The example above repackages a `jar` or `war` archive that is built during the package phase of the Maven lifecycle, including any `provided` dependencies that are defined in the project.
If some of these dependencies need to be excluded, you can use one of the `exclude` options; see the xref:packaging.adoc#packaging.examples.exclude-dependency[dependency exclusion] for more details.

The original (that is non-executable) artifact is renamed to `.original` by default but it is also possible to keep the original artifact using a custom classifier.

NOTE: The `outputFileNameMapping` feature of the `maven-war-plugin` is currently not supported.

The `spring-boot-devtools` and `spring-boot-docker-compose` modules are automatically excluded by default (you can control this using the `excludeDevtools` and `excludeDockerCompose` properties).
In order to make that work with `war` packaging, the `spring-boot-devtools` and `spring-boot-docker-compose` dependencies must be set as `optional` or with the `provided` scope.

The plugin rewrites your manifest, and in particular it manages the `Main-Class` and `Start-Class` entries.
If the defaults don't work you have to configure the values in the Spring Boot plugin, not in the jar plugin.
The `Main-Class` in the manifest is controlled by the `layout` property of the Spring Boot plugin, as shown in the following example:

[source,xml,indent=0,subs="verbatim,attributes"]
----
include::example$packaging/non-default-pom.xml[tags=non-default]
----

The `layout` property defaults to a value determined by the archive type (`jar` or `war`). The following layouts are available:

* `JAR`: regular executable JAR layout.
* `WAR`: executable WAR layout. `provided` dependencies are placed in `WEB-INF/lib-provided` to avoid any clash when the `war` is deployed in a servlet container.
* `ZIP` (alias to `DIR`): similar to the `JAR` layout using `PropertiesLauncher`.
* `NONE`: Bundle all dependencies and project resources. Does not bundle a bootstrap loader.

[[packaging.layers]]
== Layered Jar or War
A repackaged jar contains the application's classes and dependencies in `BOOT-INF/classes` and `BOOT-INF/lib` respectively.
Similarly, an executable war contains the application's classes in `WEB-INF/classes` and dependencies in `WEB-INF/lib` and `WEB-INF/lib-provided`.
For cases where a docker image needs to be built from the contents of a jar or war, it's useful to be able to separate these directories further so that they can be written into distinct layers.

Layered archives use the same layout as a regular repackaged jar or war, but include an additional meta-data file that describes each layer.

By default, the following layers are defined:

* `dependencies` for any dependency whose version does not contain `SNAPSHOT`.
* `spring-boot-loader` for the loader classes.
* `snapshot-dependencies` for any dependency whose version contains `SNAPSHOT`.
* `application` for local module dependencies, application classes, and resources.

Module dependencies are identified by looking at all of the modules that are part of the current build.
If a module dependency can only be resolved because it has been installed into Maven's local cache and it is not part of the current build, it will be identified as regular dependency.

The layers order is important as it determines how likely previous layers can be cached when part of the application changes.
The default order is `dependencies`, `spring-boot-loader`, `snapshot-dependencies`, `application`.
Content that is least likely to change should be added first, followed by layers that are more likely to change.

The repackaged archive includes the `layers.idx` file by default.
To disable this feature, you can do so in the following manner:

[source,xml,indent=0,subs="verbatim,attributes"]
----
include::example$packaging/disable-layers-pom.xml[tags=disable-layers]
----

[[packaging.layers.configuration]]
=== Custom Layers Configuration
Depending on your application, you may want to tune how layers are created and add new ones.
This can be done using a separate configuration file that should be registered as shown below:

[source,xml,indent=0,subs="verbatim,attributes"]
----
include::example$packaging/custom-layers-pom.xml[tags=custom-layers]
----

The configuration file describes how an archive can be separated into layers, and the order of those layers.
The following example shows how the default ordering described above can be defined explicitly:

[source,xml,indent=0,subs="verbatim,attributes"]
----
include::example$packaging/layers.xml[tags=layers]
----

The `layers` XML format is defined in three sections:

* The `<application>` block defines how the application classes and resources should be layered.
* The `<dependencies>` block defines how dependencies should be layered.
* The `<layerOrder>` block defines the order that the layers should be written.

Nested `<into>` blocks are used within `<application>` and `<dependencies>` sections to claim content for a layer.
The blocks are evaluated in the order that they are defined, from top to bottom.
Any content not claimed by an earlier block remains available for subsequent blocks to consider.

The `<into>` block claims content using nested `<include>` and `<exclude>` elements.
The `<application>` section uses Ant-style path matching for include/exclude expressions.
The `<dependencies>` section uses `group:artifact[:version]` patterns.
It also provides `<includeModuleDependencies />` and `<excludeModuleDependencies />` elements that can be used to include or exclude local module dependencies.

If no `<include>` is defined, then all content (not claimed by an earlier block) is considered.

If no `<exclude>` is defined, then no exclusions are applied.

Looking at the `<dependencies>` example above, we can see that the first `<into>` will claim all module dependencies for the `application.layer`.
The next `<into>` will claim all SNAPSHOT dependencies for the `snapshot-dependencies` layer.
The final `<into>` will claim anything left (in this case, any dependency that is not a SNAPSHOT) for the `dependencies` layer.

The `<application>` block has similar rules.
First claiming `org/springframework/boot/loader/**` content for the `spring-boot-loader` layer.
Then claiming any remaining classes and resources for the `application` layer.

NOTE: The order that `<into>` blocks are defined is often different from the order that the layers are written.
For this reason the `<layerOrder>` element must always be included and _must_ cover all layers referenced by the `<into>` blocks.

include::partial$goals/repackage.adoc[leveloffset=+1]

[[packaging.examples]]
== Examples

[[packaging.examples.custom-classifier]]
=== Custom Classifier
By default, the `repackage` goal replaces the original artifact with the repackaged one.
That is a sane behavior for modules that represent an application but if your module is used as a dependency of another module, you need to provide a classifier for the repackaged one.
The reason for that is that application classes are packaged in `BOOT-INF/classes` so that the dependent module cannot load a repackaged jar's classes.

If that is the case or if you prefer to keep the original artifact and attach the repackaged one with a different classifier, configure the plugin as shown in the following example:

[source,xml,indent=0,subs="verbatim,attributes"]
----
include::example$packaging/different-classifier-pom.xml[tags=different-classifier]
----

If you are using `spring-boot-starter-parent`, the `repackage` goal is executed automatically in an execution with id `repackage`.
In that setup, only the configuration should be specified, as shown in the following example:

[source,xml,indent=0,subs="verbatim,attributes"]
----
include::example$packaging/repackage-configuration-pom.xml[tags=repackage-configuration]
----

This configuration will generate two artifacts: the original one and the repackaged counter part produced by the repackage goal.
Both will be installed/deployed transparently.

You can also use the same configuration if you want to repackage a secondary artifact the same way the main artifact is replaced.
The following configuration installs/deploys a single `task` classified artifact with the repackaged application:

[source,xml,indent=0,subs="verbatim,attributes"]
----
include::example$packaging/classified-artifact-pom.xml[tags=classified-artifact]
----

As both the `maven-jar-plugin` and the `spring-boot-maven-plugin` runs at the same phase, it is important that the jar plugin is defined first (so that it runs before the repackage goal).
Again, if you are using `spring-boot-starter-parent`, this can be simplified as follows:

[source,xml,indent=0,subs="verbatim,attributes"]
----
include::example$packaging/jar-plugin-first-pom.xml[tags=jar-plugin-first]
----

[[packaging.examples.custom-name]]
=== Custom Name
If you need the repackaged jar to have a different local name than the one defined by the `artifactId` attribute of the project, use the standard `finalName`, as shown in the following example:

[source,xml,indent=0,subs="verbatim,attributes"]
----
include::example$packaging/custom-name-pom.xml[tags=custom-name]
----

This configuration will generate the repackaged artifact in `target/my-app.jar`.

[[packaging.examples.local-artifact]]
=== Local Repackaged Artifact
By default, the `repackage` goal replaces the original artifact with the executable one.
If you need to only deploy the original jar and yet be able to run your app with the regular file name, configure the plugin as follows:

[source,xml,indent=0,subs="verbatim,attributes"]
----
include::example$packaging/local-repackaged-artifact-pom.xml[tags=local-repackaged-artifact]
----

This configuration generates two artifacts: the original one and the executable counter part produced by the `repackage` goal.
Only the original one will be installed/deployed.

[[packaging.examples.custom-layout]]
=== Custom Layout
Spring Boot repackages the jar file for this project using a custom layout factory defined in the additional jar file, provided as a dependency to the build plugin:

[source,xml,indent=0,subs="verbatim,attributes"]
----
include::example$packaging/custom-layout-pom.xml[tags=custom-layout]
----

The layout factory is provided as an implementation of `LayoutFactory` (from `spring-boot-loader-tools`) explicitly specified in the pom.
If there is only one custom `LayoutFactory` on the plugin classpath and it is listed in `META-INF/spring.factories` then it is unnecessary to explicitly set it in the plugin configuration.

Layout factories are always ignored if an explicit xref:#packaging.repackage-goal.parameter-details.layout-factory[layout] is set.

[[packaging.examples.exclude-dependency]]
=== Dependency Exclusion
By default, both the `repackage` and the `run` goals will include any `provided` dependencies that are defined in the project.
A Spring Boot project should consider `provided` dependencies as "container" dependencies that are required to run the application.
Generally speaking, Spring Boot projects are not used as dependencies and are therefore unlikely to have any `optional` dependencies.
When a project does have optional dependencies they too will be included by the `repackage` and `run` goals.

Some of these dependencies may not be required at all and should be excluded from the executable jar.
For consistency, they should not be present either when running the application.

There are two ways one can exclude a dependency from being packaged/used at runtime:

* Exclude a specific artifact identified by `groupId` and `artifactId`, optionally with a `classifier` if needed.
* Exclude any artifact belonging to a given `groupId`.

The following example excludes `com.example:module1`, and only that artifact:

[source,xml,indent=0,subs="verbatim,attributes"]
----
include::example$packaging/exclude-artifact-pom.xml[tags=exclude-artifact]
----

This example excludes any artifact belonging to the `com.example` group:

[source,xml,indent=0,subs="verbatim,attributes"]
----
include::example$packaging/exclude-artifact-group-pom.xml[tags=exclude-artifact-group]
----

[[packaging.examples.layered-archive-tools]]
=== JAR Tools
When a layered jar or war is created, the `spring-boot-jarmode-tools` jar will be added as a dependency to your archive.
With this jar on the classpath, you can launch your application in a special mode which allows the bootstrap code to run something entirely different from your application, for example, something that extracts the layers.
If you wish to exclude this dependency, you can do so in the following manner:

[source,xml,indent=0,subs="verbatim,attributes"]
----
include::example$packaging/exclude-dependency-pom.xml[tags=exclude-dependency]
----

[[packaging.examples.custom-layers-configuration]]
=== Custom Layers Configuration
The default setup splits dependencies into snapshot and non-snapshot, however, you may have more complex rules.
For example, you may want to isolate company-specific dependencies of your project in a dedicated layer.
The following `layers.xml` configuration shown one such setup:

[source,xml,indent=0,subs="verbatim,attributes"]
----
include::example$packaging/layers-configuration.xml[tags=layers-configuration]
----

The configuration above creates an additional `company-dependencies` layer with all libraries with the `com.acme` groupId.
